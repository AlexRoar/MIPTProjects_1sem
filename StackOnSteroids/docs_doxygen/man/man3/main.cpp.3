.TH "StackOnSteroids/main.cpp" 3 "Sat Oct 3 2020" "StackRigid" \" -*- nroff -*-
.ad l
.nh
.SH NAME
StackOnSteroids/main.cpp
.SH SYNOPSIS
.br
.PP
\fC#include 'StackRigid\&.h'\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBStackElementDump\fP(FILE,  VALUE)   {\fBfprintf\fP(FILE, '%g', VALUE);}"
.br
.ti -1c
.RI "#define \fBStackElementType\fP   int"
.br
.RI "Element type to be used in Stack\&. "
.ti -1c
.RI "#define \fBStackElementType\fP   double"
.br
.RI "Element type to be used in Stack\&. "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBmain\fP (int argc, const char *argv[])"
.br
.RI "Here, I try somehow to break the Stack\&. "
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define StackElementDump(FILE, VALUE)   {\fBfprintf\fP(FILE, '%g', VALUE);}"

.SS "#define StackElementType   int"

.PP
Element type to be used in Stack\&. 
.SS "#define StackElementType   double"

.PP
Element type to be used in Stack\&. 
.SH "Function Documentation"
.PP 
.SS "int main (int argc, const char * argv[])"

.PP
Here, I try somehow to break the Stack\&. 
.PP
.nf
23                                         {
24     StackRigid_int* newStack = NewStackRigid_int(1000, stdout);
25     printf("  size_t volume: %lu bytes\n", sizeof(size_t));
26     printf("checksum volume: %lu bytes\n", sizeof(uint32_t));
27     for(size_t i = 0; i< 1000; i++){
28         StackPush_int(&newStack, (int)i);
29     }
30     for(size_t i = 0; i < 1000; i++){
31         int tmpVal;
32         StackPop_int(&newStack, &tmpVal);
33 //        printf("Popped %d\n", tmpVal);
34     }
35     for(size_t i = 0; i < 100; i++){
36         StackPush_int(&newStack, (int)i);
37     }
38     
39     StackRigid_double* newStackDouble = NewStackRigid_double(1000, stdout);
40     for(size_t i = 0; i< 1000; i++){
41         StackPush_double(&newStackDouble, (double)(i));
42     }
43     for(size_t i = 0; i < 1000; i++){
44         double tmpVal;
45         StackPop_double(&newStackDouble, &tmpVal);
46 //        printf("Popped %d\n", tmpVal);
47     }
48     for(size_t i = 0; i < 100; i++){
49         StackPush_double(&newStackDouble, (double)i/(double)rand());
50     }
51     
52     for(size_t i = 0; i < StackRigidMemoryUse_int(newStack); i++){
53         char previousValue = *((char*)newStack + i);
54         for (char bullet = -128; bullet < 127; bullet++){
55             if (bullet == previousValue)
56                 continue;
57             *((char*)newStack + i) = bullet;
58             StackRigidState state = StackValidate_int(newStack);
59             if (state != STACK_ST_INTEGRITYERR){
60                 printf("Did not spot intervention at position %zu, byte %x\n", i, bullet);
61                 break;
62             }
63             *((char*)newStack + i) = previousValue;
64         }
65     }
66 
67     StackDump_int(newStack);
68     StackDump_double(newStackDouble);
69     StackDestruct_int(&newStack);
70     return 0;
71 }
.fi
.PP
References i, and STACK_ST_INTEGRITYERR\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for StackRigid from the source code\&.
