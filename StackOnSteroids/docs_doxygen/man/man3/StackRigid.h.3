.TH "StackOnSteroids/StackRigid.h" 3 "Sat Oct 3 2020" "StackRigid" \" -*- nroff -*-
.ad l
.nh
.SH NAME
StackOnSteroids/StackRigid.h
.SH SYNOPSIS
.br
.PP
\fC#include <stdlib\&.h>\fP
.br
\fC#include <stdio\&.h>\fP
.br
\fC#include <assert\&.h>\fP
.br
\fC#include <time\&.h>\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fB__overload\fP(FUNC,  TYPE)   \fBEVALUATOR\fP(FUNC, TYPE)"
.br
.ti -1c
.RI "#define \fBEVALUATOR\fP(x,  y)   \fBPASTER\fP(x,y)"
.br
.ti -1c
.RI "#define \fBPASTER\fP(x,  y)   x ## _ ## y"
.br
.ti -1c
.RI "#define \fBStackElementDump\fP(FILE,  VALUE)   {fprintf(FILE, '%d', VALUE);}"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef enum \fBStackRigidOperationCodes\fP \fBStackRigidOperationCodes\fP"
.br
.RI "Codes returned after operations on Stack\&. "
.ti -1c
.RI "typedef enum \fBStackRigidState\fP \fBStackRigidState\fP"
.br
.RI "Codes characterizing Stack state\&. "
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBStackRigidOperationCodes\fP { \fBSTACK_OP_OK\fP, \fBSTACK_OP_UNDERFLOW\fP, \fBSTACK_OP_OVERFLOW\fP, \fBSTACK_OP_NOMEMORY\fP, \fBSTACK_OP_INTEGRITYERR\fP, \fBSTACK_OP_NULL\fP }"
.br
.RI "Codes returned after operations on Stack\&. "
.ti -1c
.RI "enum \fBStackRigidState\fP { \fBSTACK_ST_OK\fP, \fBSTACK_ST_INTEGRITYERR\fP, \fBSTACK_ST_UNINITIALIZED\fP, \fBSTACK_ST_NULL\fP }"
.br
.RI "Codes characterizing Stack state\&. "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "struct \fB__overload\fP (StackRigid, \fBStackElementType\fP) __overload(StackRigid"
.br
.RI "The main structure\&. "
.ti -1c
.RI "static uint32_t \fB__StackGetChecksum\fP (\fB__overload\fP(StackRigid, \fBStackElementType\fP) *stack)"
.br
.RI "Claculates big Stack checksum\&. Uses Adler-32 method\&. "
.ti -1c
.RI "static uint32_t \fB__StackGetChecksumVital\fP (\fB__overload\fP(StackRigid, \fBStackElementType\fP) *stack)"
.br
.RI "Uses Adler-32 method\&. Calculates Stack checksum only for the vital parameters\&. This is necessary because \fB__StackGetChecksum()\fP relies on capacity and size\&. If they were changed, behaviour is undefined\&. "
.ti -1c
.RI "static \fBStackRigidOperationCodes\fP \fB__StackRealocate\fP (\fB__overload\fP(StackRigid, \fBStackElementType\fP) **stack, short int direction)"
.br
.RI "Realocates Stack if needed\&. "
.ti -1c
.RI "static void \fB__StackUpdateChecksum\fP (\fB__overload\fP(StackRigid, \fBStackElementType\fP) *stack)"
.br
.RI "Updates Stack checksums\&. Does not take into account bytes inside the stack but outside of its last element\&. "
.ti -1c
.RI "static uint32_t \fBadlerChecksum\fP (const void *firstBlock, size_t len)"
.br
.RI "Calculates Adler-32 checksum from the firstBlock to the firstBlock + len\&. "
.ti -1c
.RI "\fBStackRigidOperationCodes\fP \fBStackBack\fP (\fB__overload\fP(StackRigid, \fBStackElementType\fP) *stack, \fBStackElementType\fP *value)"
.br
.RI "Free stack memory\&. "
.ti -1c
.RI "\fBStackRigidOperationCodes\fP \fBStackDestruct\fP (\fB__overload\fP(StackRigid, \fBStackElementType\fP) **stack)"
.br
.RI "Free stack memory\&. "
.ti -1c
.RI "void \fBStackDump\fP (\fB__overload\fP(StackRigid, \fBStackElementType\fP) *stack)"
.br
.RI "Dumps debug information about the stack\&. "
.ti -1c
.RI "\fBStackElementType\fP (const size_t capacity, FILE *logFile)"
.br
.ti -1c
.RI "\fBStackRigidOperationCodes\fP \fBStackPop\fP (\fB__overload\fP(StackRigid, \fBStackElementType\fP) **stack, \fBStackElementType\fP *value)"
.br
.RI "Pop value from the end of the stack The operation can perform realocations if there is too much space\&. "
.ti -1c
.RI "\fBStackRigidOperationCodes\fP \fBStackPush\fP (\fB__overload\fP(StackRigid, \fBStackElementType\fP) **stack, \fBStackElementType\fP value)"
.br
.RI "Push the value to the stack The operation can perform realocations if there is not enough space\&. "
.ti -1c
.RI "size_t \fBStackRigidMemoryUse\fP (\fB__overload\fP(StackRigid, \fBStackElementType\fP) *stack)"
.br
.RI "Memory alocated for the Stack\&. "
.ti -1c
.RI "\fBStackRigidState\fP \fBStackValidate\fP (\fB__overload\fP(StackRigid, \fBStackElementType\fP) *stack)"
.br
.RI "Perform all stack checks: checksums, general constrains\&. "
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define __overload(FUNC, TYPE)   \fBEVALUATOR\fP(FUNC, TYPE)"

.SS "#define EVALUATOR(x, y)   \fBPASTER\fP(x,y)"

.SS "#define PASTER(x, y)   x ## _ ## y"

.SS "#define StackElementDump(FILE, VALUE)   {fprintf(FILE, '%d', VALUE);}"

.SH "Typedef Documentation"
.PP 
.SS "typedef enum \fBStackRigidOperationCodes\fP \fBStackRigidOperationCodes\fP"

.PP
Codes returned after operations on Stack\&. 
.SS "typedef enum \fBStackRigidState\fP \fBStackRigidState\fP"

.PP
Codes characterizing Stack state\&. 
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBStackRigidOperationCodes\fP"

.PP
Codes returned after operations on Stack\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fISTACK_OP_OK \fP\fP
Succesful operation\&. 
.TP
\fB\fISTACK_OP_UNDERFLOW \fP\fP
Tried to get value from the empty stack\&. 
.TP
\fB\fISTACK_OP_OVERFLOW \fP\fP
Stack overflow and new memory allocation failed\&. 
.TP
\fB\fISTACK_OP_NOMEMORY \fP\fP
No memory for stack alocations\&. 
.TP
\fB\fISTACK_OP_INTEGRITYERR \fP\fP
Stack memory was altered by some outer access\&. 
.TP
\fB\fISTACK_OP_NULL \fP\fP
Found NULL pointer during the operation\&. 
.PP
.nf
46                                      {
50     STACK_OP_OK,
54     STACK_OP_UNDERFLOW,
58     STACK_OP_OVERFLOW,
62     STACK_OP_NOMEMORY,
66     STACK_OP_INTEGRITYERR,
70     STACK_OP_NULL
71 } StackRigidOperationCodes;
.fi
.SS "enum \fBStackRigidState\fP"

.PP
Codes characterizing Stack state\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fISTACK_ST_OK \fP\fP
Stack is running as expected\&. 
.TP
\fB\fISTACK_ST_INTEGRITYERR \fP\fP
Stack was altered by some outer access\&. 
.TP
\fB\fISTACK_ST_UNINITIALIZED \fP\fP
Stack is uninitialized\&. 
.TP
\fB\fISTACK_ST_NULL \fP\fP
Found NULL pointer during the operation\&. 
.PP
.nf
77                             {
81     STACK_ST_OK,
85     STACK_ST_INTEGRITYERR,
89     STACK_ST_UNINITIALIZED,
93     STACK_ST_NULL
94 } StackRigidState;
.fi
.SH "Function Documentation"
.PP 
.SS "__overload (StackRigid, \fBStackElementType\fP)"

.PP
The main structure\&. Create new stack with pre-defined capacity\&.
.PP
There's no definition in the header file in order to block direct parameters access
.PP
\fBParameters\fP
.RS 4
\fIcapacity\fP initial stack capacity\&. Set to 0 if yo want the stack to adopt automaticaly\&. 
.br
\fIlogFile\fP file for logging 
.RE
.PP
\fBReturns\fP
.RS 4
new stack pointer 
.RE
.PP

.PP
.nf
106                                                {
107     int32_t checkSum;
108     uint32_t checkSumVital;
109     size_t capacity;
110     size_t size;
111     FILE* logFile;
112     StackElementType data[1];
113 };
.fi
.SS "static uint32_t __StackGetChecksum (\fB__overload\fP(StackRigid, \fBStackElementType\fP) * stack)\fC [static]\fP"

.PP
Claculates big Stack checksum\&. Uses Adler-32 method\&. 
.PP
\fBAttention\fP
.RS 4
Not for the manual use! 
.PP
.nf
* Stack memory : [ checkSum checkSumVital capacity size logFile | value 1, value 2, ..., value n || ___garbage area___]
* ________________from here ^__________________________________________________________^to here
* 
.fi
.PP
 
.RE
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack that checksums are needed to be updated 
.RE
.PP

.PP
.nf
369                                                                                     {
370     assert(stack);
371     
372     void* firstBlock = (char*)stack + sizeof(stack->checkSum);
373     
374     // Memory used by Stack excluding checkSum and free space
375     #ifndef DEBUG
376         const size_t memory = StackRigidMemoryUse(stack) - sizeof(stack->checkSum) - (stack->capacity - stack->size) * sizeof(StackElementType);
377     #endif
378     #ifdef DEBUG
379         const size_t memory = StackRigidMemoryUse(stack) - sizeof(stack->checkSum);
380     #endif
381     
382     if (stack->size > stack->capacity) {
383         return 0;
384     }
385     return adlerChecksum(firstBlock, memory);
386 }
.fi
.PP
References adlerChecksum(), StackElementType(), and StackRigidMemoryUse()\&.
.PP
Referenced by __StackUpdateChecksum(), and StackValidate()\&.
.SS "static uint32_t __StackGetChecksumVital (\fB__overload\fP(StackRigid, \fBStackElementType\fP) * stack)\fC [static]\fP"

.PP
Uses Adler-32 method\&. Calculates Stack checksum only for the vital parameters\&. This is necessary because \fB__StackGetChecksum()\fP relies on capacity and size\&. If they were changed, behaviour is undefined\&. 
.PP
\fBAttention\fP
.RS 4
Not for the manual use!
.RE
.PP
.PP
.nf
* Stack memory : [ checkSum checkSumVital capacity size logFile | value 1, value 2, ..., value n || ___garbage area___]
* ______________________________from here ^__________________^to here
* .fi
.PP
 
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack that checksums are needed to be updated 
.RE
.PP

.PP
.nf
356                                                                                          {
357     assert(stack);
358     
359     void* firstBlock = (char*)stack + sizeof(stack->checkSum) + sizeof(stack->checkSumVital);
360     
361     const size_t memory = sizeof(stack->size) + sizeof(stack->capacity)+ sizeof(stack->logFile);
362     if (stack->size > stack->capacity) {
363         return 0;
364     }
365     return adlerChecksum(firstBlock, memory);
366 }
.fi
.PP
References adlerChecksum()\&.
.PP
Referenced by __StackUpdateChecksum(), and StackValidate()\&.
.SS "static \fBStackRigidOperationCodes\fP __StackRealocate (\fB__overload\fP(StackRigid, \fBStackElementType\fP) ** stack, short int direction)\fC [static]\fP"

.PP
Realocates Stack if needed\&. 
.PP
\fBAttention\fP
.RS 4
Not for the manual use! 
.RE
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack to be realocated 
.br
\fIdirection\fP which direction realocations are available\&. > 0 -> expand space if needed, < 0 -> shrink space if needed 
.RE
.PP

.PP
.nf
389                                                                                                                         {
390     if ((*stack)->capacity == 0) {
391         (*stack)->capacity = 16;
392         
393         const size_t memory = StackRigidMemoryUse(*stack);
394         
395          __overload(StackRigid,StackElementType)* newStack = ( __overload(StackRigid,StackElementType)*) realloc((*stack), memory);
396         if (newStack == NULL)
397             return STACK_OP_NOMEMORY;
398         
399         (*stack) = newStack;
400     }else if(((*stack)->capacity <= (*stack)->size) && direction > 0) {
401         // Up realocation
402         size_t newCapacity = (*stack)->size * 2;
403         
404         if (newCapacity <= (*stack)->size) { //   If we exceeded size_t range
405             newCapacity = (*stack)->size + 16; // Try to add 16 free spaces
406             if (newCapacity < (*stack)->size) //  Even if in this case we still exceed size_t
407                 return STACK_OP_OVERFLOW;
408         }
409         
410         const size_t memoryNow = StackRigidMemoryUse(*stack);
411         const size_t memoryNew = sizeof(__overload(StackRigid,StackElementType)) + (newCapacity - 1) * sizeof(StackElementType);
412         
413         if (memoryNew >= memoryNow) {
414              __overload(StackRigid,StackElementType)* newStack = ( __overload(StackRigid,StackElementType)*) realloc((*stack), memoryNew);
415             if (newStack == NULL)
416                 return STACK_OP_NOMEMORY;
417             
418             (*stack) = newStack;
419         }else{
420             return STACK_OP_OVERFLOW; // Exceded size_t memory
421         }
422         (*stack)->capacity = newCapacity;
423         
424     }else if (((*stack)->capacity / 2\&.2 > (*stack)->size) && direction < 0) {
425         // Down realocation
426         size_t newCapacity = (*stack)->capacity / 2\&.2;
427         
428         const size_t memoryNow = StackRigidMemoryUse(*stack);
429         const size_t memoryNew = sizeof(__overload(StackRigid,StackElementType)) + (newCapacity - 1) * sizeof(StackElementType);
430         
431         if (memoryNew <= memoryNow) {
432              __overload(StackRigid,StackElementType)* newStack = ( __overload(StackRigid,StackElementType)*) realloc((*stack), memoryNew);
433             if (newStack == NULL)
434                 return STACK_OP_NOMEMORY;
435             
436             (*stack) = newStack;
437             (*stack)->capacity = newCapacity;
438         }else
439             return STACK_OP_OVERFLOW; // Exceded size_t memory
440     }
441     return STACK_OP_OK;
442 }
.fi
.PP
References __overload, STACK_OP_NOMEMORY, STACK_OP_OK, STACK_OP_OVERFLOW, StackElementType(), and StackRigidMemoryUse()\&.
.PP
Referenced by StackPop(), and StackPush()\&.
.SS "static void __StackUpdateChecksum (\fB__overload\fP(StackRigid, \fBStackElementType\fP) * stack)\fC [static]\fP"

.PP
Updates Stack checksums\&. Does not take into account bytes inside the stack but outside of its last element\&. 
.PP
\fBAttention\fP
.RS 4
Not for the manual use! 
.PP
.nf
* Stack memory :  [ __stack area__ | value 1, value 2, ..., value n || ___garbage area___]
* ____________________________________________________________________^ alterations in this area are not checked
* 
.fi
.PP
 
.RE
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack that checksums are needed to be updated 
.RE
.PP

.PP
.nf
347                                                                                    {
348     assert(stack);
349 
350     stack->checkSumVital = __StackGetChecksumVital(stack);
351     stack->checkSum = __StackGetChecksum(stack);
352 
353 }
.fi
.PP
References __StackGetChecksum(), and __StackGetChecksumVital()\&.
.PP
Referenced by StackElementType(), StackPop(), and StackPush()\&.
.SS "static uint32_t adlerChecksum (const void * firstBlock, size_t len)\fC [static]\fP"

.PP
Calculates Adler-32 checksum from the firstBlock to the firstBlock + len\&. 
.PP
\fBAttention\fP
.RS 4
Not for the manual use! 
.RE
.PP
\fBParameters\fP
.RS 4
\fIfirstBlock\fP first block to include to the checksum 
.br
\fIlen\fP length of byte sequence 
.RE
.PP
\fBReturns\fP
.RS 4
checksum 
.RE
.PP

.PP
.nf
32                                                                   {
33     uint32_t a = 1, b = 0;
34     const uint32_t MOD_ADLER = 65521;
35     for (size_t index = 0; index < len; ++index) {
36         a = (a + ((char*)firstBlock)[index]) % MOD_ADLER;
37         b = (b + a) % MOD_ADLER;
38     }
39     return (b << 16) | a;
40 }
.fi
.PP
Referenced by __StackGetChecksum(), and __StackGetChecksumVital()\&.
.SS "\fBStackRigidOperationCodes\fP StackBack (\fB__overload\fP(StackRigid, \fBStackElementType\fP) * stack, \fBStackElementType\fP * value)"

.PP
Free stack memory\&. 
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack to be used 
.RE
.PP
\fBReturns\fP
.RS 4
the outcome of the operation 
.RE
.PP

.PP
.nf
308                                                                                                             {
309     if (stack == NULL)
310         return STACK_OP_NULL;
311     
312     StackRigidState integrityChecks = StackValidate(stack);
313     if (integrityChecks != STACK_ST_OK) {
314         StackDump(stack);
315         return STACK_OP_INTEGRITYERR;
316     }
317     
318     if(stack->size == 0)
319         return STACK_OP_UNDERFLOW;
320     
321     *value = stack->data[stack->size - 1];
322     return STACK_OP_OK;
323 }
.fi
.PP
References STACK_OP_INTEGRITYERR, STACK_OP_NULL, STACK_OP_OK, STACK_OP_UNDERFLOW, STACK_ST_OK, StackDump(), and StackValidate()\&.
.SS "\fBStackRigidOperationCodes\fP StackDestruct (\fB__overload\fP(StackRigid, \fBStackElementType\fP) ** stack)"

.PP
Free stack memory\&. 
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack to be distructed 
.RE
.PP
\fBReturns\fP
.RS 4
the outcome of the operation 
.RE
.PP

.PP
.nf
525                                                                                          {
526     if (stack == NULL) {
527         return STACK_OP_NULL;
528     }
529     if (*stack == NULL) {
530         return STACK_OP_NULL;
531     }
532     free(*stack);
533     return STACK_OP_OK;
534 }
.fi
.PP
References STACK_OP_NULL, and STACK_OP_OK\&.
.PP
Referenced by main()\&.
.SS "void StackDump (\fB__overload\fP(StackRigid, \fBStackElementType\fP) * stack)"

.PP
Dumps debug information about the stack\&. 
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack to be dumped 
.RE
.PP

.PP
.nf
450                                                                 {
451     time_t rawtime = time(NULL);
452     struct tm *ptm = localtime(&rawtime);
453     
454     FILE* output = stack->logFile;
455     if (output == NULL) {
456         output = stdout;
457         printf("\nWarning! Specified dump output is inavailbale! Selecting stdout\&.\n");
458     }
459     
460     fprintf(output, "=================================\n");
461     fprintf(output, "Stack dump %s", asctime(ptm));
462     
463     if (stack == NULL) {
464         fprintf(output, "\nStack dump is impossible: NULL pointer\n");
465     }else{
466         fprintf(output, "Stack (");
467         const char *status = "ok";
468         StackRigidState checks = StackValidate(stack);
469         switch (checks) {
470             case STACK_ST_INTEGRITYERR:
471                 status = "INTEGRITY ERROR SPOTTED";
472                 break;
473             case STACK_ST_UNINITIALIZED:
474                 status = "UNINITIALIZED";
475                 break;
476             case STACK_ST_OK:
477                 status = "ok";
478                 break;
479             case STACK_ST_NULL:
480                 status = "NULL POINTER";
481                 break;
482         }
483         fprintf(output, "%s", status);
484         fprintf(output, ")");
485         fprintf(output, " [%p]: {\n", stack);
486         if (checks == STACK_ST_INTEGRITYERR) {
487             fprintf(output, "ERROR! Stack structure was corrupted\&. The data below was changed from the outside\&.\n");
488         }
489         fprintf(output, "\t    size : %lu\n", stack->size);
490         fprintf(output, "\tcapacity : %lu\n", stack->capacity);
491         fprintf(output, "\tcheckSum : %x\n", stack->checkSum);
492         
493         fprintf(output, "\tdata [%p]: {\n", stack->data);
494         size_t i = 0;
495         for (i = 0; i < stack->size; i++) {
496             fprintf(output, "\t\t");
497             fprintf(output, "*[%lu] : ", i);
498             StackElementDump(stack->logFile, stack->data[i]);
499             fprintf(output, "\n");
500         }
501         fprintf(output, "\t\t _______\n");
502         if (stack->size < stack->capacity) {
503             fprintf(output, "\t\t [%lu] : GARBAGE(", i + 1);
504             StackElementDump(stack->logFile, stack->data[i + 1]);
505             fprintf(output, ")\n");
506         }
507         if (stack->size + 1 < stack->capacity && stack->size + 1 > stack->size) {
508             fprintf(output, "\t\t [%lu] : GARBAGE(", i + 2);
509             StackElementDump(stack->logFile, stack->data[i + 2]);
510             fprintf(output, ")\n");
511         }
512         fprintf(output, "\t}\n");
513         fprintf(output, "}\n");
514         
515         const size_t memory = StackRigidMemoryUse(stack);
516         fprintf(output, "Size allocated : %lu bytes\n", memory);
517         fprintf(output, "Raw Stack size : %lu bytes\n", sizeof(__overload(StackRigid,StackElementType)));
518         fprintf(output, "  Element size : %lu bytes\n", sizeof(StackElementType));
519         fprintf(output, "     Block end : %p\n", (char*)stack + memory);
520     }
521     fprintf(output, "=================================\n");
522 }
.fi
.PP
References __overload, STACK_ST_INTEGRITYERR, STACK_ST_NULL, STACK_ST_OK, STACK_ST_UNINITIALIZED, StackElementDump, StackElementType(), StackRigidMemoryUse(), and StackValidate()\&.
.PP
Referenced by main(), StackBack(), StackPop(), and StackPush()\&.
.SS "StackElementType (const size_t capacity, FILE * logFile)"

.PP
.nf
267                                                                                                                            {
268     const size_t memory = sizeof( __overload(StackRigid,StackElementType)) + (capacity - 1) * sizeof(StackElementType);
269      __overload(StackRigid,StackElementType)* pointer = ( __overload(StackRigid,StackElementType)*)calloc(memory, 1);
270     if (pointer == NULL) {
271         return NULL;
272     }
273     
274     pointer->capacity = capacity;
275     pointer->size = 0;
276     pointer->logFile = logFile;
277     pointer->checkSum = 0;
278     pointer->checkSumVital = 0;
279     __StackUpdateChecksum(pointer);
280     return pointer;
281 }
.fi
.PP
References __overload, and __StackUpdateChecksum()\&.
.PP
Referenced by __StackGetChecksum(), __StackRealocate(), StackDump(), and StackRigidMemoryUse()\&.
.SS "\fBStackRigidOperationCodes\fP StackPop (\fB__overload\fP(StackRigid, \fBStackElementType\fP) ** stack, \fBStackElementType\fP * value)"

.PP
Pop value from the end of the stack The operation can perform realocations if there is too much space\&. 
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack to be distructed 
.br
\fIvalue\fP value to be pushed 
.RE
.PP
\fBReturns\fP
.RS 4
the outcome of the operation 
.RE
.PP

.PP
.nf
284                                                                                                              {
285     
286     if (stack == NULL)
287         return STACK_OP_NULL;
288     
289     StackRigidState integrityChecks = StackValidate(*stack);
290     if (integrityChecks != STACK_ST_OK) {
291         StackDump(*stack);
292         return STACK_OP_INTEGRITYERR;
293     }
294     
295     if((*stack)->size == 0)
296         return STACK_OP_UNDERFLOW;
297     
298     *value = (*stack)->data[(*stack)->size - 1];
299     (*stack)->size -= 1;
300     
301     __StackRealocate(stack, -1);
302     __StackUpdateChecksum(*stack);
303 
304     return STACK_OP_OK;
305 }
.fi
.PP
References __StackRealocate(), __StackUpdateChecksum(), STACK_OP_INTEGRITYERR, STACK_OP_NULL, STACK_OP_OK, STACK_OP_UNDERFLOW, STACK_ST_OK, StackDump(), and StackValidate()\&.
.PP
Referenced by main()\&.
.SS "\fBStackRigidOperationCodes\fP StackPush (\fB__overload\fP(StackRigid, \fBStackElementType\fP) ** stack, \fBStackElementType\fP value)"

.PP
Push the value to the stack The operation can perform realocations if there is not enough space\&. 
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack to be changed 
.br
\fIvalue\fP value to be pushed 
.RE
.PP
\fBReturns\fP
.RS 4
the outcome of the operation 
.RE
.PP

.PP
.nf
239                                                                                                             {
240     if (stack == NULL)
241         return STACK_OP_NULL;
242     
243     StackRigidState integrityChecks = StackValidate(*stack);
244     if (integrityChecks != STACK_ST_OK) {
245         StackDump(*stack);
246         return STACK_OP_INTEGRITYERR;
247     }
248     
249     StackRigidOperationCodes realocResult = __StackRealocate(stack, 1);
250     if (realocResult != STACK_OP_OK) {
251         StackDump(*stack);
252         return realocResult;
253     }
254     
255     (*stack)->data[(*stack)->size] = value;
256     (*stack)->size += 1;
257     
258     __StackUpdateChecksum(*stack);
259     
260     if ((*stack)->size == 0) {
261         return STACK_OP_OVERFLOW;
262     }
263     return STACK_OP_OK;
264 }
.fi
.PP
References __StackRealocate(), __StackUpdateChecksum(), STACK_OP_INTEGRITYERR, STACK_OP_NULL, STACK_OP_OK, STACK_OP_OVERFLOW, STACK_ST_OK, StackDump(), and StackValidate()\&.
.PP
Referenced by main()\&.
.SS "size_t StackRigidMemoryUse (\fB__overload\fP(StackRigid, \fBStackElementType\fP) * stack)"

.PP
Memory alocated for the Stack\&. 
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack to be checked 
.RE
.PP
\fBReturns\fP
.RS 4
alocated bytes 
.RE
.PP

.PP
.nf
444                                                                             {
445     assert(stack);
446     return sizeof(__overload(StackRigid,StackElementType)) + (stack->capacity - 1) * sizeof(StackElementType);
447 }
.fi
.PP
References __overload, and StackElementType()\&.
.PP
Referenced by __StackGetChecksum(), __StackRealocate(), main(), and StackDump()\&.
.SS "\fBStackRigidState\fP StackValidate (\fB__overload\fP(StackRigid, \fBStackElementType\fP) * stack)"

.PP
Perform all stack checks: checksums, general constrains\&. 
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack to be validated 
.RE
.PP
\fBReturns\fP
.RS 4
calculated state 
.RE
.PP

.PP
.nf
326                                                                                {
327  
328     if (stack == NULL)
329         return STACK_ST_NULL;
330     
331     if (stack->size > stack->capacity || stack->checkSum == 0 || stack->checkSumVital == 0)
332         return STACK_ST_INTEGRITYERR;
333     
334     uint32_t currentChecksumVital = __StackGetChecksumVital(stack);
335     if (currentChecksumVital != stack->checkSumVital || currentChecksumVital == 0)
336         return STACK_ST_INTEGRITYERR;
337     
338     uint32_t currentChecksum = __StackGetChecksum(stack);
339     if (currentChecksum != stack->checkSum || currentChecksum == 0)
340         return STACK_ST_INTEGRITYERR;
341     
342 
343     return STACK_ST_OK;
344 }
.fi
.PP
References __StackGetChecksum(), __StackGetChecksumVital(), STACK_ST_INTEGRITYERR, STACK_ST_NULL, and STACK_ST_OK\&.
.PP
Referenced by main(), StackBack(), StackDump(), StackPop(), and StackPush()\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for StackRigid from the source code\&.
