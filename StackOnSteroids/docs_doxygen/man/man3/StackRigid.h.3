.TH "StackOnSteroids/StackRigid.h" 3 "Mon Oct 5 2020" "StackRigid" \" -*- nroff -*-
.ad l
.nh
.SH NAME
StackOnSteroids/StackRigid.h
.SH SYNOPSIS
.br
.PP
\fC#include <stdlib\&.h>\fP
.br
\fC#include <stdio\&.h>\fP
.br
\fC#include <assert\&.h>\fP
.br
\fC#include <time\&.h>\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fB__overload\fP(FUNC)   \fBEVALUATOR\fP(FUNC, \fBStackElementType\fP)"
.br
.ti -1c
.RI "#define \fBEVALUATOR\fP(x,  y)   \fBPASTER\fP(x,y)"
.br
.ti -1c
.RI "#define \fBPASTER\fP(x,  y)   x ## _ ## y"
.br
.ti -1c
.RI "#define \fBStackElementDump\fP(FILE,  VALUE)   {fprintf(FILE, '%d', VALUE);}"
.br
.RI "Default element dump instruction\&. "
.ti -1c
.RI "#define \fBStackElementType\fP   int"
.br
.RI "By default, it would be stack of ints\&. "
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef enum \fBStackRigidOperationCodes\fP \fBStackRigidOperationCodes\fP"
.br
.RI "Codes returned after operations on Stack\&. "
.ti -1c
.RI "typedef enum \fBStackRigidState\fP \fBStackRigidState\fP"
.br
.RI "Codes characterizing Stack state\&. "
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBStackRigidOperationCodes\fP { \fBSTACK_OP_OK\fP, \fBSTACK_OP_UNDERFLOW\fP, \fBSTACK_OP_OVERFLOW\fP, \fBSTACK_OP_NOMEMORY\fP, \fBSTACK_OP_INTEGRITYERR\fP, \fBSTACK_OP_NULL\fP, \fBSTACK_OP_PTRINVALID\fP }"
.br
.RI "Codes returned after operations on Stack\&. "
.ti -1c
.RI "enum \fBStackRigidState\fP { \fBSTACK_ST_OK\fP, \fBSTACK_ST_INTEGRITYERR\fP, \fBSTACK_ST_UNINITIALIZED\fP, \fBSTACK_ST_NULL\fP }"
.br
.RI "Codes characterizing Stack state\&. "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "struct \fB__overload\fP (StackRigid) = ( __overload(StackRigid)*)calloc(memory, 1)"
.br
.RI "The main StackRigid struct\&. "
.ti -1c
.RI "static uint32_t \fB__StackGetChecksum\fP (\fB__overload\fP(StackRigid) *stack)"
.br
.RI "Claculates big Stack checksum\&. Uses Adler-32 method\&. "
.ti -1c
.RI "static uint32_t \fB__StackGetChecksumVital\fP (\fB__overload\fP(StackRigid) *stack)"
.br
.RI "Uses Adler-32 method\&. Calculates Stack checksum only for the vital parameters\&. This is necessary because \fB__StackGetChecksum()\fP relies on capacity and size\&. If they were changed, behaviour is undefined\&. "
.ti -1c
.RI "static \fBStackRigidOperationCodes\fP \fB__StackRealocate\fP (\fB__overload\fP(StackRigid) **stack, short int direction)"
.br
.RI "Realocates Stack if needed\&. "
.ti -1c
.RI "static void \fB__StackUpdateChecksum\fP (\fB__overload\fP(StackRigid) *stack)"
.br
.RI "Updates Stack checksums\&. Does not take into account bytes inside the stack but outside of its last element\&. "
.ti -1c
.RI "\fB__StackUpdateChecksum\fP (\fBpointer\fP)"
.br
.ti -1c
.RI "static uint32_t \fBadlerChecksum\fP (const void *firstBlock, size_t len)"
.br
.RI "Calculates Adler-32 checksum from the firstBlock to the firstBlock + len\&. "
.ti -1c
.RI "\fBif\fP (!\fBvalidPtr\fP(\fBpointer\fP))"
.br
.ti -1c
.RI "\fBStackRigidOperationCodes\fP \fBStackBack\fP (\fB__overload\fP(StackRigid) *stack, \fBStackElementType\fP *value)"
.br
.RI "Free stack memory\&. "
.ti -1c
.RI "\fBStackRigidOperationCodes\fP \fBStackDestruct\fP (\fB__overload\fP(StackRigid) **stack)"
.br
.RI "Free stack memory\&. "
.ti -1c
.RI "void \fBStackDump\fP (\fB__overload\fP(StackRigid) *stack)"
.br
.RI "Dumps debug information about the stack\&. "
.ti -1c
.RI "\fBStackRigidOperationCodes\fP \fBStackPop\fP (\fB__overload\fP(StackRigid) **stack, \fBStackElementType\fP *value)"
.br
.RI "Pop value from the end of the stack The operation can perform realocations if there is too much space\&. "
.ti -1c
.RI "\fBStackRigidOperationCodes\fP \fBStackPush\fP (\fB__overload\fP(StackRigid) **stack, \fBStackElementType\fP value)"
.br
.RI "Push the value to the stack The operation can perform realocations if there is not enough space\&. "
.ti -1c
.RI "size_t \fBStackRigidMemoryUse\fP (\fB__overload\fP(StackRigid) *stack)"
.br
.RI "Memory alocated for the Stack\&. "
.ti -1c
.RI "\fBStackRigidState\fP \fBStackValidate\fP (\fB__overload\fP(StackRigid) *stack)"
.br
.RI "Perform all stack checks: checksums, general constrains\&. "
.ti -1c
.RI "static int \fBvalidPtr\fP (void *ptr)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBpointer\fP \fBcapacity\fP = capacity"
.br
.ti -1c
.RI "\fBpointer\fP \fBcheckSum\fP = 0"
.br
.ti -1c
.RI "\fBpointer\fP \fBcheckSumVital\fP = 0"
.br
.ti -1c
.RI "FILE * \fBlogFile\fP"
.br
.ti -1c
.RI "return \fBpointer\fP"
.br
.ti -1c
.RI "\fBpointer\fP \fBsize\fP = 0"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define __overload(FUNC)   \fBEVALUATOR\fP(FUNC, \fBStackElementType\fP)"

.SS "#define EVALUATOR(x, y)   \fBPASTER\fP(x,y)"

.SS "#define PASTER(x, y)   x ## _ ## y"

.SS "#define StackElementDump(FILE, VALUE)   {fprintf(FILE, '%d', VALUE);}"

.PP
Default element dump instruction\&. 
.SS "#define StackElementType   int"

.PP
By default, it would be stack of ints\&. 
.SH "Typedef Documentation"
.PP 
.SS "typedef enum \fBStackRigidOperationCodes\fP \fBStackRigidOperationCodes\fP"

.PP
Codes returned after operations on Stack\&. 
.SS "typedef enum \fBStackRigidState\fP \fBStackRigidState\fP"

.PP
Codes characterizing Stack state\&. 
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBStackRigidOperationCodes\fP"

.PP
Codes returned after operations on Stack\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fISTACK_OP_OK \fP\fP
Succesful operation\&. 
.TP
\fB\fISTACK_OP_UNDERFLOW \fP\fP
Tried to get value from the empty stack\&. 
.TP
\fB\fISTACK_OP_OVERFLOW \fP\fP
Stack overflow and new memory allocation failed\&. 
.TP
\fB\fISTACK_OP_NOMEMORY \fP\fP
No memory for stack alocations\&. 
.TP
\fB\fISTACK_OP_INTEGRITYERR \fP\fP
Stack memory was altered by some outer access\&. 
.TP
\fB\fISTACK_OP_NULL \fP\fP
Found NULL pointer during the operation\&. 
.TP
\fB\fISTACK_OP_PTRINVALID \fP\fP
Found invalid pointer during the operation\&. 
.PP
.nf
47                                      {
51     STACK_OP_OK,
55     STACK_OP_UNDERFLOW,
59     STACK_OP_OVERFLOW,
63     STACK_OP_NOMEMORY,
67     STACK_OP_INTEGRITYERR,
71     STACK_OP_NULL,
75     STACK_OP_PTRINVALID
76 } StackRigidOperationCodes;
.fi
.SS "enum \fBStackRigidState\fP"

.PP
Codes characterizing Stack state\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fISTACK_ST_OK \fP\fP
Stack is running as expected\&. 
.TP
\fB\fISTACK_ST_INTEGRITYERR \fP\fP
Stack was altered by some outer access\&. 
.TP
\fB\fISTACK_ST_UNINITIALIZED \fP\fP
Stack is uninitialized\&. 
.TP
\fB\fISTACK_ST_NULL \fP\fP
Found NULL pointer during the operation\&. 
.PP
.nf
82                             {
86     STACK_ST_OK,
90     STACK_ST_INTEGRITYERR,
94     STACK_ST_UNINITIALIZED,
98     STACK_ST_NULL
99 } StackRigidState;
.fi
.SH "Function Documentation"
.PP 
.SS "__overload (StackRigid) = ( __overload(StackRigid)*)calloc(memory, 1)"

.PP
The main StackRigid struct\&. Create new stack with pre-defined capacity\&.
.PP
\fBParameters\fP
.RS 4
\fIcapacity\fP initial stack capacity\&. Set to 0 if you want the stack to adopt automaticaly\&. 
.br
\fIlogFile\fP file for logging 
.RE
.PP
\fBReturns\fP
.RS 4
new stack pointer 
.RE
.PP

.PP
.nf
129                               {
130     int32_t checkSum;
131     uint32_t checkSumVital;
132     size_t capacity;
133     size_t size;
134     FILE* logFile;
135     StackElementType data[1];
136 };
.fi
.SS "static uint32_t __StackGetChecksum (\fB__overload\fP(StackRigid) * stack)\fC [static]\fP"

.PP
Claculates big Stack checksum\&. Uses Adler-32 method\&. 
.PP
\fBAttention\fP
.RS 4
Not for the manual use! 
.PP
.nf
* Stack memory : [ checkSum checkSumVital capacity size logFile | value 1, value 2, ..., value n || ___garbage area___]
* Release:
* ________________from here ^__________________________________________________________^to here
* Debug:
* ________________from here ^______________________________________________________________________________^to here
* 
.fi
.PP
 
.RE
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack that checksums are needed to be updated 
.RE
.PP

.PP
.nf
396                                                                    {
397     assert(stack);
398     
399     void* firstBlock = (char*)stack + sizeof(stack->checkSum);
400     
401     // Memory used by Stack excluding checkSum and free space
402     #ifndef DEBUG
403         const size_t memory = StackRigidMemoryUse(stack) - sizeof(stack->checkSum) - (stack->capacity - stack->size) * sizeof(StackElementType);
404     #endif
405     #ifdef DEBUG
406         const size_t memory = StackRigidMemoryUse(stack) - sizeof(stack->checkSum);
407     #endif
408     
409     if (stack->size > stack->capacity) {
410         return 0;
411     }
412     return adlerChecksum(firstBlock, memory);
413 }
.fi
.PP
References adlerChecksum(), StackElementType, and StackRigidMemoryUse()\&.
.PP
Referenced by __StackUpdateChecksum(), and StackValidate()\&.
.SS "static uint32_t __StackGetChecksumVital (\fB__overload\fP(StackRigid) * stack)\fC [static]\fP"

.PP
Uses Adler-32 method\&. Calculates Stack checksum only for the vital parameters\&. This is necessary because \fB__StackGetChecksum()\fP relies on capacity and size\&. If they were changed, behaviour is undefined\&. 
.PP
\fBAttention\fP
.RS 4
Not for the manual use!
.RE
.PP
.PP
.nf
* Stack memory : [ checkSum checkSumVital capacity size logFile | value 1, value 2, ..., value n || ___garbage area___]
* ______________________________from here ^__________________^to here
* .fi
.PP
 
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack that checksums are needed to be updated 
.RE
.PP

.PP
.nf
383                                                                         {
384     assert(stack);
385     
386     void* firstBlock = (char*)stack + sizeof(stack->checkSum) + sizeof(stack->checkSumVital);
387     
388     const size_t memory = (char*)(stack->data) - (char*)firstBlock;
389     if (stack->size > stack->capacity) {
390         return 0;
391     }
392     return adlerChecksum(firstBlock, memory);
393 }
.fi
.PP
References adlerChecksum()\&.
.PP
Referenced by __StackUpdateChecksum(), and StackValidate()\&.
.SS "static \fBStackRigidOperationCodes\fP __StackRealocate (\fB__overload\fP(StackRigid) ** stack, short int direction)\fC [static]\fP"

.PP
Realocates Stack if needed\&. 
.PP
\fBAttention\fP
.RS 4
Not for the manual use! 
.RE
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack to be realocated 
.br
\fIdirection\fP which direction realocations are available\&. > 0 -> expand space if needed, < 0 -> shrink space if needed 
.RE
.PP

.PP
.nf
416                                                                                                        {
417     if ((*stack)->capacity == 0) {
418         (*stack)->capacity = 16; // capacity if was 0
419         
420         const size_t memory = StackRigidMemoryUse(*stack);
421         
422          __overload(StackRigid)* newStack = ( __overload(StackRigid)*) realloc((*stack), memory);
423         if (!validPtr(newStack))
424             return STACK_OP_NOMEMORY;
425         
426         (*stack) = newStack;
427     }else if(((*stack)->capacity <= (*stack)->size) && direction > 0) { // Up realocation
428         size_t newCapacity = (*stack)->size * 2;
429         
430         if (newCapacity <= (*stack)->size) { //   If we exceeded size_t range
431             newCapacity = (*stack)->size + 16; // Try to add 16 free spaces
432             if (newCapacity < (*stack)->size) //  Even if in this case we still exceed size_t
433                 return STACK_OP_OVERFLOW;
434         }
435         
436         const size_t memoryNow = StackRigidMemoryUse(*stack);
437         const size_t memoryNew = sizeof(__overload(StackRigid)) + (newCapacity - 1) * sizeof(StackElementType);
438         
439         if (memoryNew >= memoryNow) {
440              __overload(StackRigid)* newStack = ( __overload(StackRigid)*) realloc((*stack), memoryNew);
441             if (!validPtr(newStack))
442                 return STACK_OP_NOMEMORY;
443             
444             (*stack) = newStack;
445         }else{
446             return STACK_OP_OVERFLOW; // Exceded size_t memory
447         }
448         (*stack)->capacity = newCapacity;
449         
450     }else if (((*stack)->capacity / 2\&.2 > (*stack)->size) && direction < 0) { // Down realocation
451         size_t newCapacity = (*stack)->capacity / 2\&.2;
452         
453         const size_t memoryNow = StackRigidMemoryUse(*stack);
454         const size_t memoryNew = sizeof(__overload(StackRigid)) + (newCapacity - 1) * sizeof(StackElementType);
455         
456         if (memoryNew <= memoryNow) {
457              __overload(StackRigid)* newStack = ( __overload(StackRigid)*) realloc((*stack), memoryNew);
458             if (!validPtr(newStack))
459                 return STACK_OP_NOMEMORY;
460             
461             (*stack) = newStack;
462             (*stack)->capacity = newCapacity;
463         }else
464             return STACK_OP_OVERFLOW; // Exceded size_t memory
465     }
466     return STACK_OP_OK;
467 }
.fi
.PP
References __overload, STACK_OP_NOMEMORY, STACK_OP_OK, STACK_OP_OVERFLOW, StackElementType, StackRigidMemoryUse(), and validPtr()\&.
.PP
Referenced by StackPop(), and StackPush()\&.
.SS "static void __StackUpdateChecksum (\fB__overload\fP(StackRigid) * stack)\fC [static]\fP"

.PP
Updates Stack checksums\&. Does not take into account bytes inside the stack but outside of its last element\&. 
.PP
\fBAttention\fP
.RS 4
Not for the manual use! 
.PP
.nf
* Stack memory :  [ __stack area__ | value 1, value 2, ..., value n || ___garbage area___]
* ____________________________________________________________________^ alterations in this area are not checked
* 
.fi
.PP
 
.RE
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack that checksums are needed to be updated 
.RE
.PP

.PP
.nf
375                                                                   {
376     assert(stack);
377 
378     stack->checkSumVital = __StackGetChecksumVital(stack);
379     stack->checkSum = __StackGetChecksum(stack);
380 }
.fi
.PP
References __StackGetChecksum(), and __StackGetChecksumVital()\&.
.PP
Referenced by StackPop(), and StackPush()\&.
.SS "__StackUpdateChecksum (\fBpointer\fP)"

.SS "static uint32_t adlerChecksum (const void * firstBlock, size_t len)\fC [static]\fP"

.PP
Calculates Adler-32 checksum from the firstBlock to the firstBlock + len\&. 
.PP
\fBAttention\fP
.RS 4
Not for the manual use! 
.RE
.PP
\fBParameters\fP
.RS 4
\fIfirstBlock\fP first block to include to the checksum 
.br
\fIlen\fP length of byte sequence 
.RE
.PP
\fBReturns\fP
.RS 4
checksum 
.RE
.PP

.PP
.nf
109                                                                   {
110     uint32_t a = 1, b = 0;
111     const uint32_t MOD_ADLER = 65521;
112     for (size_t index = 0; index < len; ++index) {
113         a = (a + ((char*)firstBlock)[index]) % MOD_ADLER;
114         b = (b + a) % MOD_ADLER;
115     }
116     return (b << 16) | a;
117 }
.fi
.PP
Referenced by __StackGetChecksum(), and __StackGetChecksumVital()\&.
.SS "if (! validPtrpointer)"

.PP
.nf
296                             {
297         return NULL;
298     }
.fi
.SS "\fBStackRigidOperationCodes\fP StackBack (\fB__overload\fP(StackRigid) * stack, \fBStackElementType\fP * value)"

.PP
Free stack memory\&. 
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack to be used 
.RE
.PP
\fBReturns\fP
.RS 4
the outcome of the operation 
.RE
.PP

.PP
.nf
335                                                                                            {
336     if (!validPtr(stack))
337         return STACK_OP_NULL;
338     
339     
340     StackRigidState integrityChecks = StackValidate(stack);
341     
342     if (integrityChecks != STACK_ST_OK) {
343         StackDump(stack);
344         return STACK_OP_INTEGRITYERR;
345     }
346     
347     if(stack->size == 0)
348         return STACK_OP_UNDERFLOW;
349     
350     *value = stack->data[stack->size - 1];
351     return STACK_OP_OK;
352 }
.fi
.PP
References STACK_OP_INTEGRITYERR, STACK_OP_NULL, STACK_OP_OK, STACK_OP_UNDERFLOW, STACK_ST_OK, StackDump(), StackValidate(), and validPtr()\&.
.SS "\fBStackRigidOperationCodes\fP StackDestruct (\fB__overload\fP(StackRigid) ** stack)"

.PP
Free stack memory\&. 
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack to be distructed 
.RE
.PP
\fBReturns\fP
.RS 4
the outcome of the operation 
.RE
.PP

.PP
.nf
561                                                                         {
562     if (!validPtr(stack)) {
563         return STACK_OP_NULL;
564     }
565     if (!validPtr(*stack)) {
566         return STACK_OP_NULL;
567     }
568     StackRigidState checks = StackValidate(*stack);
569     if (checks == STACK_ST_OK){
570         const size_t memoryNow = StackRigidMemoryUse(*stack);
571         for(char* cursor = (char*)(*stack); cursor < (char*)(*stack) + memoryNow; cursor++)
572             *cursor = 0;
573     }
574     free(*stack);
575     return STACK_OP_OK;
576 }
.fi
.PP
References STACK_OP_NULL, STACK_OP_OK, STACK_ST_OK, StackRigidMemoryUse(), StackValidate(), and validPtr()\&.
.PP
Referenced by main()\&.
.SS "void StackDump (\fB__overload\fP(StackRigid) * stack)"

.PP
Dumps debug information about the stack\&. 
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack to be dumped 
.RE
.PP

.PP
.nf
475                                                {
476     time_t rawtime = time(NULL);
477     struct tm *ptm = localtime(&rawtime);
478     
479     FILE* output = stack->logFile;
480     if (!validPtr(output)) {
481         output = stdout;
482         printf("\nWarning! Specified dump output is inavailbale! Selecting stdout\&.\n");
483     }
484     
485     fprintf(output, "=================================\n");
486     fprintf(output, "Stack dump %s", asctime(ptm));
487     
488     if (!validPtr(stack)) {
489         fprintf(output, "\nStack dump is impossible: NULL pointer\n");
490     }else{
491         fprintf(output, "Stack (");
492         const char *status = "ok";
493         StackRigidState checks = StackValidate(stack);
494         switch (checks) {
495             case STACK_ST_INTEGRITYERR:
496                 status = "INTEGRITY ERROR SPOTTED";
497                 break;
498             case STACK_ST_UNINITIALIZED:
499                 status = "UNINITIALIZED";
500                 break;
501             case STACK_ST_OK:
502                 status = "ok";
503                 break;
504             case STACK_ST_NULL:
505                 status = "NULL POINTER";
506                 break;
507         }
508         fprintf(output, "%s", status);
509         fprintf(output, ")");
510         fprintf(output, " [%p]: {\n", stack);
511         if (checks != STACK_ST_OK) {
512             fprintf(output, "ERROR! Stack structure was corrupted\&.\nThe data below was changed from the outside\&.\nThis can fail!\n");
513         }
514         fprintf(output, "\t         size : %lu\n", stack->size);
515         fprintf(output, "\t     capacity : %lu\n", stack->capacity);
516         fprintf(output, "\t     checkSum : %x\n", stack->checkSumVital);
517         fprintf(output, "\tcheckSumVital : %x\n", stack->checkSum);
518         
519         fprintf(output, "\tdata [%p]: {\n", stack->data);
520         if (checks == STACK_ST_OK) {
521         size_t i = 0;
522         for (i = 0; i < stack->size; i++) {
523             fprintf(output, "\t\t");
524             fprintf(output, "*[%lu] : ", i);
525             fprintf(output, "[%p] ", stack->data + i);
526             StackElementDump(stack->logFile, stack->data[i]);
527             fprintf(output, "\n");
528         }
529         fprintf(output, "\t\t _______\n");
530         if (stack->size  < stack->capacity) {
531             fprintf(output, "\t\t [%lu] : GARBAGE(", i);
532             fprintf(output, "[%p] ", stack->data + i);
533             StackElementDump(stack->logFile, stack->data[i]);
534             fprintf(output, ")\n");
535         }
536         if (stack->size + 1< stack->capacity && stack->size + 1 > stack->size) {
537             fprintf(output, "\t\t [%lu] : GARBAGE(", i + 1);
538             fprintf(output, "[%p] ", stack->data + i + 1);
539             StackElementDump(stack->logFile, stack->data[i + 1]);
540             fprintf(output, ")\n");
541         }
542         } else{
543             fprintf(output, "\t\tDATA CAN'T BE READED\n");
544         }
545         
546         fprintf(output, "\t}\n");
547         fprintf(output, "}\n");
548         
549         const size_t memory = StackRigidMemoryUse(stack);
550         fprintf(output, "Size allocated : %lu bytes\n", memory);
551         fprintf(output, "Raw Stack size : %lu bytes\n", sizeof(__overload(StackRigid)));
552         fprintf(output, "  Element size : %lu bytes\n", sizeof(StackElementType));
553         fprintf(output, "     Block end : %p\n", (char*)stack + memory);
554     }
555     fprintf(output, "=================================\n");
556     fflush(NULL);
557     
558 }
.fi
.PP
References __overload, STACK_ST_INTEGRITYERR, STACK_ST_NULL, STACK_ST_OK, STACK_ST_UNINITIALIZED, StackElementDump, StackElementType, StackRigidMemoryUse(), StackValidate(), and validPtr()\&.
.PP
Referenced by main(), StackBack(), StackPop(), and StackPush()\&.
.SS "\fBStackRigidOperationCodes\fP StackPop (\fB__overload\fP(StackRigid) ** stack, \fBStackElementType\fP * value)"

.PP
Pop value from the end of the stack The operation can perform realocations if there is too much space\&. 
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack to be distructed 
.br
\fIvalue\fP value to be pushed 
.RE
.PP
\fBReturns\fP
.RS 4
the outcome of the operation 
.RE
.PP

.PP
.nf
311                                                                                             {
312     if (!validPtr(stack))
313         return STACK_OP_NULL;
314     
315     StackRigidState integrityChecks = StackValidate(*stack);
316     
317     if (integrityChecks != STACK_ST_OK) {
318         StackDump(*stack);
319         return STACK_OP_INTEGRITYERR;
320     }
321     
322     if((*stack)->size == 0)
323         return STACK_OP_UNDERFLOW;
324     
325     *value = (*stack)->data[(*stack)->size - 1];
326     (*stack)->size -= 1;
327     
328     __StackRealocate(stack, -1);
329     __StackUpdateChecksum(*stack);
330 
331     return STACK_OP_OK;
332 }
.fi
.PP
References __StackRealocate(), __StackUpdateChecksum(), STACK_OP_INTEGRITYERR, STACK_OP_NULL, STACK_OP_OK, STACK_OP_UNDERFLOW, STACK_ST_OK, StackDump(), StackValidate(), and validPtr()\&.
.PP
Referenced by main()\&.
.SS "\fBStackRigidOperationCodes\fP StackPush (\fB__overload\fP(StackRigid) ** stack, \fBStackElementType\fP value)"

.PP
Push the value to the stack The operation can perform realocations if there is not enough space\&. 
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack to be changed 
.br
\fIvalue\fP value to be pushed 
.RE
.PP
\fBReturns\fP
.RS 4
the outcome of the operation 
.RE
.PP

.PP
.nf
257                                                                                            {
258     if (!validPtr(stack))
259         return STACK_OP_PTRINVALID;
260     if (!validPtr(*stack))
261         return STACK_OP_PTRINVALID;
262     
263     
264     StackRigidState integrityChecks = StackValidate(*stack);
265     
266     if (integrityChecks != STACK_ST_OK) {
267         StackDump(*stack);
268         return STACK_OP_INTEGRITYERR;
269     }
270     
271     
272     StackRigidOperationCodes realocResult = __StackRealocate(stack, 1);
273     
274     if (realocResult != STACK_OP_OK) {
275         StackDump(*stack);
276         return realocResult;
277     }
278     
279     (*stack)->data[(*stack)->size] = value;
280     (*stack)->size += 1;
281     
282     __StackUpdateChecksum(*stack);
283     
284     if ((*stack)->size == 0) {
285         return STACK_OP_OVERFLOW;
286     }
287     return STACK_OP_OK;
288 }
.fi
.PP
References __StackRealocate(), __StackUpdateChecksum(), STACK_OP_INTEGRITYERR, STACK_OP_OK, STACK_OP_OVERFLOW, STACK_OP_PTRINVALID, STACK_ST_OK, StackDump(), StackValidate(), and validPtr()\&.
.PP
Referenced by main()\&.
.SS "size_t StackRigidMemoryUse (\fB__overload\fP(StackRigid) * stack)"

.PP
Memory alocated for the Stack\&. 
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack to be checked 
.RE
.PP
\fBReturns\fP
.RS 4
alocated bytes 
.RE
.PP

.PP
.nf
469                                                            {
470     assert(stack);
471     return sizeof(__overload(StackRigid)) + (stack->capacity - 1) * sizeof(StackElementType);
472 }
.fi
.PP
References __overload, and StackElementType\&.
.PP
Referenced by __StackGetChecksum(), __StackRealocate(), main(), StackDestruct(), and StackDump()\&.
.SS "\fBStackRigidState\fP StackValidate (\fB__overload\fP(StackRigid) * stack)"

.PP
Perform all stack checks: checksums, general constrains\&. 
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack to be validated 
.RE
.PP
\fBReturns\fP
.RS 4
calculated state 
.RE
.PP

.PP
.nf
355                                                               {
356     if (!validPtr(stack))
357         return STACK_ST_NULL;
358     
359     if (stack->size > stack->capacity || stack->checkSum == 0 || stack->checkSumVital == 0)
360         return STACK_ST_INTEGRITYERR;
361     
362     uint32_t currentChecksumVital = __StackGetChecksumVital(stack);
363     if (currentChecksumVital != stack->checkSumVital || currentChecksumVital == 0)
364         return STACK_ST_INTEGRITYERR;
365     
366     uint32_t currentChecksum = __StackGetChecksum(stack);
367     if (currentChecksum != stack->checkSum || currentChecksum == 0)
368         return STACK_ST_INTEGRITYERR;
369     
370 
371     return STACK_ST_OK;
372 }
.fi
.PP
References __StackGetChecksum(), __StackGetChecksumVital(), STACK_ST_INTEGRITYERR, STACK_ST_NULL, STACK_ST_OK, and validPtr()\&.
.PP
Referenced by main(), StackBack(), StackDestruct(), StackDump(), StackPop(), and StackPush()\&.
.SS "static int validPtr (void * ptr)\fC [static]\fP"

.PP
.nf
119                                {
120     return (ptr != NULL);
121 }
.fi
.PP
Referenced by __StackRealocate(), StackBack(), StackDestruct(), StackDump(), StackPop(), StackPush(), and StackValidate()\&.
.SH "Variable Documentation"
.PP 
.SS "\fBpointer\fP capacity = capacity"

.SS "\fBpointer\fP checkSum = 0"

.SS "\fBpointer\fP checkSumVital = 0"

.SS "\fBpointer\fP logFile"
\fBInitial value:\fP
.PP
.nf
{
    const size_t memory = sizeof( __overload(StackRigid)) + (capacity - 1) * sizeof(StackElementType)
.fi
.SS "return pointer"

.SS "\fBpointer\fP size = 0"

.SH "Author"
.PP 
Generated automatically by Doxygen for StackRigid from the source code\&.
