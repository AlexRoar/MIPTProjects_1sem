.TH "StackOnSteroids/StackRigid.h" 3 "Fri Oct 9 2020" "StackRigid" \" -*- nroff -*-
.ad l
.nh
.SH NAME
StackOnSteroids/StackRigid.h
.SH SYNOPSIS
.br
.PP
\fC#include <stdlib\&.h>\fP
.br
\fC#include <stdio\&.h>\fP
.br
\fC#include <assert\&.h>\fP
.br
\fC#include <time\&.h>\fP
.br
\fC#include 'PointerChecks\&.h'\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fB__overload\fP(FUNC)   \fBEVALUATOR\fP(FUNC, \fBStackElementType\fP)"
.br
.ti -1c
.RI "#define \fBEVALUATOR\fP(x,  y)   \fBPASTER\fP(x,y)"
.br
.ti -1c
.RI "#define \fBPASTER\fP(x,  y)   x ## _ ## y"
.br
.ti -1c
.RI "#define \fBStackDumpWrapper\fP(stack)   { \fBStackDump\fP(stack, __LINE__, __FILE__, ''); }"
.br
.ti -1c
.RI "#define \fBStackDumpWrapperWhy\fP(stack,  why)   { \fBStackDump\fP(stack, __LINE__, __FILE__, why); }"
.br
.ti -1c
.RI "#define \fBStackElementDump\fP(FILE,  VALUE)   {fprintf(FILE, '%d', VALUE);}"
.br
.RI "Default element dump instruction\&. "
.ti -1c
.RI "#define \fBStackElementType\fP   int"
.br
.RI "By default, it will be stack of ints\&. "
.ti -1c
.RI "#define \fBStackRigid_h\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef enum \fBStackRigidOperationCodes\fP \fBStackRigidOperationCodes\fP"
.br
.RI "Codes returned after operations on Stack\&. "
.ti -1c
.RI "typedef enum \fBStackRigidState\fP \fBStackRigidState\fP"
.br
.RI "Codes characterizing Stack state\&. "
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBStackRigidOperationCodes\fP { \fBSTACK_OP_OK\fP, \fBSTACK_OP_UNDERFLOW\fP, \fBSTACK_OP_OVERFLOW\fP, \fBSTACK_OP_NOMEMORY\fP, \fBSTACK_OP_INTEGRITYERR\fP, \fBSTACK_OP_NULL\fP, \fBSTACK_OP_PTRINVALID\fP }"
.br
.RI "Codes returned after operations on Stack\&. "
.ti -1c
.RI "enum \fBStackRigidState\fP { \fBSTACK_ST_OK\fP, \fBSTACK_ST_INTEGRITYERR\fP, \fBSTACK_ST_UNINITIALIZED\fP, \fBSTACK_ST_NULL\fP }"
.br
.RI "Codes characterizing Stack state\&. "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "struct \fB__overload\fP (StackRigid) = ( __overload(StackRigid)*)calloc(\fBmemory\fP, 1)"
.br
.RI "The main StackRigid struct\&. "
.ti -1c
.RI "static uint32_t \fB__StackGetChecksum\fP (\fB__overload\fP(StackRigid) *stack)"
.br
.RI "Claculates big Stack checksum\&. Uses Adler-32 method\&. "
.ti -1c
.RI "static uint32_t \fB__StackGetChecksumVital\fP (\fB__overload\fP(StackRigid) *stack)"
.br
.RI "Uses Adler-32 method\&. Calculates Stack checksum only for the vital parameters\&. This is necessary because \fB__StackGetChecksum()\fP relies on capacity and size\&. If they were changed, behaviour is undefined\&. "
.ti -1c
.RI "static \fBStackRigidOperationCodes\fP \fB__StackReallocate\fP (\fB__overload\fP(StackRigid) **stack, short int direction)"
.br
.RI "Reallocates Stack if needed\&. "
.ti -1c
.RI "static void \fB__StackUpdateChecksum\fP (\fB__overload\fP(StackRigid) *stack)"
.br
.RI "Updates Stack checksums\&. Does not take into account bytes inside the stack but outside of its last element\&. "
.ti -1c
.RI "\fB__StackUpdateChecksum\fP (\fBpointer\fP)"
.br
.ti -1c
.RI "static uint32_t \fBadlerChecksum\fP (const void *firstBlock, size_t len)"
.br
.RI "Calculates Adler-32 checksum from the firstBlock to the firstBlock + len\&. "
.ti -1c
.RI "\fBif\fP (!istack_pointer_valid(\fBlogFile\fP, sizeof(\fBlogFile\fP)))"
.br
.ti -1c
.RI "\fBif\fP (!istack_pointer_valid(\fBpointer\fP, sizeof(\fBpointer\fP)))"
.br
.ti -1c
.RI "\fBif\fP (\fBadded\fP< \fBmemory\fP)"
.br
.ti -1c
.RI "\fBStackRigidOperationCodes\fP \fBStackBack\fP (\fB__overload\fP(StackRigid) *stack, \fBStackElementType\fP *value)"
.br
.RI "Free stack memory\&. "
.ti -1c
.RI "\fBStackRigidOperationCodes\fP \fBStackDestruct\fP (\fB__overload\fP(StackRigid) **stack)"
.br
.RI "Free stack memory\&. "
.ti -1c
.RI "void \fBStackDump\fP (\fB__overload\fP(StackRigid) *stack, const int line, const char *file, const char *why)"
.br
.RI "Dumps debug information about the stack\&. "
.ti -1c
.RI "\fBStackRigidOperationCodes\fP \fBStackPop\fP (\fB__overload\fP(StackRigid) **stack, \fBStackElementType\fP *value)"
.br
.RI "Pop value from the end of the stack The operation can perform reallocations if there is too much space\&. "
.ti -1c
.RI "\fBStackRigidOperationCodes\fP \fBStackPush\fP (\fB__overload\fP(StackRigid) **stack, \fBStackElementType\fP value)"
.br
.RI "Push the value to the stack The operation can perform reallocations if there is not enough space\&. "
.ti -1c
.RI "size_t \fBStackRigidMemoryUse\fP (\fB__overload\fP(StackRigid) *stack)"
.br
.RI "Memory alocated for the Stack\&. "
.ti -1c
.RI "\fBStackRigidState\fP \fBStackValidate\fP (\fB__overload\fP(StackRigid) *stack)"
.br
.RI "Perform all stack checks: checksums, general constrains\&. "
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "size_t \fBadded\fP = \fBmemory\fP + (\fBcapacity\fP \- 1) * sizeof(\fBStackElementType\fP)"
.br
.ti -1c
.RI "\fBpointer\fP \fBcapacity\fP = capacity"
.br
.ti -1c
.RI "\fBpointer\fP \fBcheckSum\fP = 0"
.br
.ti -1c
.RI "\fBpointer\fP \fBcheckSumVital\fP = 0"
.br
.ti -1c
.RI "FILE * \fBlogFile\fP"
.br
.ti -1c
.RI "size_t \fBmemory\fP = sizeof( \fB__overload\fP(StackRigid))"
.br
.ti -1c
.RI "return \fBpointer\fP"
.br
.ti -1c
.RI "\fBpointer\fP \fBsize\fP = 0"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define __overload(FUNC)   \fBEVALUATOR\fP(FUNC, \fBStackElementType\fP)"

.SS "#define EVALUATOR(x, y)   \fBPASTER\fP(x,y)"

.SS "#define PASTER(x, y)   x ## _ ## y"

.SS "#define StackDumpWrapper(stack)   { \fBStackDump\fP(stack, __LINE__, __FILE__, ''); }"

.SS "#define StackDumpWrapperWhy(stack, why)   { \fBStackDump\fP(stack, __LINE__, __FILE__, why); }"

.SS "#define StackElementDump(FILE, VALUE)   {fprintf(FILE, '%d', VALUE);}"

.PP
Default element dump instruction\&. 
.SS "#define StackElementType   int"

.PP
By default, it will be stack of ints\&. 
.SS "#define StackRigid_h"

.SH "Typedef Documentation"
.PP 
.SS "typedef enum \fBStackRigidOperationCodes\fP \fBStackRigidOperationCodes\fP"

.PP
Codes returned after operations on Stack\&. 
.SS "typedef enum \fBStackRigidState\fP \fBStackRigidState\fP"

.PP
Codes characterizing Stack state\&. 
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBStackRigidOperationCodes\fP"

.PP
Codes returned after operations on Stack\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fISTACK_OP_OK \fP\fP
Succesful operation\&. 
.TP
\fB\fISTACK_OP_UNDERFLOW \fP\fP
Tried to get value from the empty stack\&. 
.TP
\fB\fISTACK_OP_OVERFLOW \fP\fP
Stack overflow and new memory allocation failed\&. 
.TP
\fB\fISTACK_OP_NOMEMORY \fP\fP
No memory for stack alocations\&. 
.TP
\fB\fISTACK_OP_INTEGRITYERR \fP\fP
Stack memory was altered by some outer access\&. 
.TP
\fB\fISTACK_OP_NULL \fP\fP
Found NULL pointer during the operation\&. 
.TP
\fB\fISTACK_OP_PTRINVALID \fP\fP
Found invalid pointer during the operation\&. 
.PP
.nf
68                                      {
72     STACK_OP_OK,
76     STACK_OP_UNDERFLOW,
80     STACK_OP_OVERFLOW,
84     STACK_OP_NOMEMORY,
88     STACK_OP_INTEGRITYERR,
92     STACK_OP_NULL,
96     STACK_OP_PTRINVALID
97 } StackRigidOperationCodes;
.fi
.SS "enum \fBStackRigidState\fP"

.PP
Codes characterizing Stack state\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fISTACK_ST_OK \fP\fP
Stack is running as expected\&. 
.TP
\fB\fISTACK_ST_INTEGRITYERR \fP\fP
Stack was altered by some outer access\&. 
.TP
\fB\fISTACK_ST_UNINITIALIZED \fP\fP
Stack is uninitialized\&. 
.TP
\fB\fISTACK_ST_NULL \fP\fP
Found NULL pointer during the operation\&. 
.PP
.nf
103                             {
107     STACK_ST_OK,
111     STACK_ST_INTEGRITYERR,
115     STACK_ST_UNINITIALIZED,
119     STACK_ST_NULL
120 } StackRigidState;
.fi
.SH "Function Documentation"
.PP 
.SS "__overload (StackRigid) = ( __overload(StackRigid)*)calloc(\fBmemory\fP, 1)"

.PP
The main StackRigid struct\&. Create new stack with pre-defined capacity\&.
.PP
\fBParameters\fP
.RS 4
\fIcapacity\fP initial stack capacity\&. Set to 0 if you want the stack to adopt automaticaly\&. 
.br
\fIlogFile\fP file for logging 
.RE
.PP
\fBReturns\fP
.RS 4
new stack pointer or NULL if impossible 
.RE
.PP

.PP
.nf
146                               {
147     uint32_t checkSum;
148     uint32_t checkSumVital;
149     size_t capacity;
150     size_t size;
151     FILE* logFile;
152     StackElementType data[1];
153 };
.fi
.SS "static uint32_t __StackGetChecksum (\fB__overload\fP(StackRigid) * stack)\fC [static]\fP"

.PP
Claculates big Stack checksum\&. Uses Adler-32 method\&. 
.PP
\fBAttention\fP
.RS 4
Not for the manual use! 
.PP
.nf
* Stack memory : [ checkSum checkSumVital capacity size logFile | value 1, value 2, ..., value n || ___garbage area___]
* Release:
* ________________from here ^__________________________________________________________^to here
* Debug:
* ________________from here ^______________________________________________________________________________^to here
* 
.fi
.PP
 
.RE
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack that checksums are needed to be updated 
.RE
.PP

.PP
.nf
426                                                                    {
427     assert(stack);
428     
429     void* firstBlock = (char*)stack + sizeof(stack->checkSum);
430     
431     // Memory used by Stack excluding checkSum and free space
432     #ifndef DEBUG
433         const size_t memory = StackRigidMemoryUse(stack) - sizeof(stack->checkSum) - (stack->capacity - stack->size) * sizeof(StackElementType);
434     #endif
435     #ifdef DEBUG
436         const size_t memory = StackRigidMemoryUse(stack) - sizeof(stack->checkSum);
437     #endif
438     
439     if (stack->size > stack->capacity) {
440         return 0;
441     }
442     return adlerChecksum(firstBlock, memory);
443 }
.fi
.PP
References adlerChecksum(), memory, StackElementType, and StackRigidMemoryUse()\&.
.PP
Referenced by __StackUpdateChecksum(), and StackValidate()\&.
.SS "static uint32_t __StackGetChecksumVital (\fB__overload\fP(StackRigid) * stack)\fC [static]\fP"

.PP
Uses Adler-32 method\&. Calculates Stack checksum only for the vital parameters\&. This is necessary because \fB__StackGetChecksum()\fP relies on capacity and size\&. If they were changed, behaviour is undefined\&. 
.PP
\fBAttention\fP
.RS 4
Not for the manual use!
.RE
.PP
.PP
.nf
* Stack memory : [ checkSum checkSumVital capacity size logFile | value 1, value 2, ..., value n || ___garbage area___]
* ______________________________from here ^__________________^to here
* .fi
.PP
 
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack that checksums are needed to be updated 
.RE
.PP

.PP
.nf
413                                                                         {
414     assert(stack);
415     
416     void* firstBlock = (char*)stack + sizeof(stack->checkSum) + sizeof(stack->checkSumVital);
417     
418     const size_t memory = (size_t)((char*)(stack->data) - (char*)firstBlock);
419     if (stack->size > stack->capacity) {
420         return 0;
421     }
422     return adlerChecksum(firstBlock, memory);
423 }
.fi
.PP
References adlerChecksum(), and memory\&.
.PP
Referenced by __StackUpdateChecksum(), and StackValidate()\&.
.SS "static \fBStackRigidOperationCodes\fP __StackReallocate (\fB__overload\fP(StackRigid) ** stack, short int direction)\fC [static]\fP"

.PP
Reallocates Stack if needed\&. 
.PP
\fBAttention\fP
.RS 4
Not for the manual use! 
.RE
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack to be reallocated 
.br
\fIdirection\fP which direction reallocations are available\&. > 0 -> expand space if needed, < 0 -> shrink space if needed 
.RE
.PP

.PP
.nf
446                                                                                                         {
447     if ((*stack)->capacity == 0) {
448         (*stack)->capacity = 16; // capacity if was 0
449         
450         const size_t memory = StackRigidMemoryUse(*stack);
451         
452          __overload(StackRigid)* newStack = ( __overload(StackRigid)*) realloc((*stack), memory);
453         if (!istack_pointer_valid(newStack, sizeof(newStack)))
454             return STACK_OP_NOMEMORY;
455         
456         (*stack) = newStack;
457     }else if(((*stack)->capacity <= (*stack)->size) && direction > 0) { // Up reallocation
458         size_t newCapacity = (*stack)->size * 2;
459         
460         if (newCapacity <= (*stack)->size) { //   If we exceeded size_t range
461             newCapacity = (*stack)->size + 16; // Try to add 16 free spaces
462             if (newCapacity < (*stack)->size) //  Even if in this case we still exceed size_t
463                 return STACK_OP_OVERFLOW;
464         }
465         
466         const size_t memoryNow = StackRigidMemoryUse(*stack);
467         const size_t memoryNew = sizeof(__overload(StackRigid)) + (newCapacity - 1) * sizeof(StackElementType);
468         
469         if (memoryNew >= memoryNow) {
470              __overload(StackRigid)* newStack = ( __overload(StackRigid)*) realloc((*stack), memoryNew);
471             if (!istack_pointer_valid(newStack, sizeof(newStack)))
472                 return STACK_OP_NOMEMORY;
473             
474             (*stack) = newStack;
475         }else{
476             return STACK_OP_OVERFLOW; // Exceded size_t memory
477         }
478         (*stack)->capacity = newCapacity;
479         
480     }else if (((*stack)->capacity / 2\&.2 > (*stack)->size) && direction < 0) { // Down reallocation
481         size_t newCapacity = (*stack)->capacity / 2\&.2;
482         
483         const size_t memoryNow = StackRigidMemoryUse(*stack);
484         const size_t memoryNew = sizeof(__overload(StackRigid)) + (newCapacity - 1) * sizeof(StackElementType);
485         
486         if (memoryNew <= memoryNow) {
487              __overload(StackRigid)* newStack = ( __overload(StackRigid)*) realloc((*stack), memoryNew);
488             if (!istack_pointer_valid(newStack, sizeof(newStack)))
489                 return STACK_OP_NOMEMORY;
490             
491             (*stack) = newStack;
492             (*stack)->capacity = newCapacity;
493         }else
494             return STACK_OP_OVERFLOW; // Exceded size_t memory
495     }
496     return STACK_OP_OK;
497 }
.fi
.PP
References __overload, memory, STACK_OP_NOMEMORY, STACK_OP_OK, STACK_OP_OVERFLOW, StackElementType, and StackRigidMemoryUse()\&.
.PP
Referenced by StackPop(), and StackPush()\&.
.SS "static void __StackUpdateChecksum (\fB__overload\fP(StackRigid) * stack)\fC [static]\fP"

.PP
Updates Stack checksums\&. Does not take into account bytes inside the stack but outside of its last element\&. 
.PP
\fBAttention\fP
.RS 4
Not for the manual use! 
.PP
.nf
* Stack memory :  [ __stack area__ | value 1, value 2, ..., value n || ___garbage area___]
* ____________________________________________________________________^ alterations in this area are not checked
* 
.fi
.PP
 
.RE
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack that checksums are needed to be updated 
.RE
.PP

.PP
.nf
404                                                                   {
405     assert(stack);
406     #ifndef IGNORE_VALIDITY
407         stack->checkSumVital = __StackGetChecksumVital(stack);
408         stack->checkSum      = __StackGetChecksum(stack);
409     #endif
410 }
.fi
.PP
References __StackGetChecksum(), and __StackGetChecksumVital()\&.
.PP
Referenced by StackPop(), and StackPush()\&.
.SS "__StackUpdateChecksum (\fBpointer\fP)"

.SS "static uint32_t adlerChecksum (const void * firstBlock, size_t len)\fC [static]\fP"

.PP
Calculates Adler-32 checksum from the firstBlock to the firstBlock + len\&. 
.PP
\fBAttention\fP
.RS 4
Not for the manual use! 
.RE
.PP
\fBParameters\fP
.RS 4
\fIfirstBlock\fP first block to include to the checksum 
.br
\fIlen\fP length of byte sequence 
.RE
.PP
\fBReturns\fP
.RS 4
checksum 
.RE
.PP

.PP
.nf
130                                                                   {
131     uint32_t a = 1, b = 0;
132     const uint32_t MOD_ADLER = 65521;
133     for (size_t index = 0; index < len; ++index) {
134         a = (a + ((unsigned char*)firstBlock)[index]) % MOD_ADLER;
135         b = (b + a) % MOD_ADLER;
136     }
137     return (b << 16) | a;
138 }
.fi
.PP
Referenced by __StackGetChecksum(), and __StackGetChecksumVital()\&.
.SS "if (! istack_pointer_validlogFile, sizeof(logFile))"

.PP
.nf
316                                                           {
317          return NULL;
318      }
.fi
.SS "if (! istack_pointer_validpointer, sizeof(pointer))"

.PP
.nf
323                                                          {
324         return NULL;
325     }
.fi
.SS "if ()"

.PP
.nf
313                          {
314          return NULL;
315      }
.fi
.SS "\fBStackRigidOperationCodes\fP StackBack (\fB__overload\fP(StackRigid) * stack, \fBStackElementType\fP * value)"

.PP
Free stack memory\&. 
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack to be used 
.RE
.PP
\fBReturns\fP
.RS 4
the outcome of the operation 
.RE
.PP

.PP
.nf
363                                                                                            {
364     if (!istack_pointer_valid(stack, sizeof(stack)))
365         return STACK_OP_NULL;
366     
367     
368     StackRigidState integrityChecks = StackValidate(stack);
369     
370     if (integrityChecks != STACK_ST_OK) {
371         StackDumpWrapperWhy(stack, "StackBack operation spotted integrity error");
372         return STACK_OP_INTEGRITYERR;
373     }
374     
375     if(stack->size == 0)
376         return STACK_OP_UNDERFLOW;
377     
378     *value = stack->data[stack->size - 1];
379     return STACK_OP_OK;
380 }
.fi
.PP
References STACK_OP_INTEGRITYERR, STACK_OP_NULL, STACK_OP_OK, STACK_OP_UNDERFLOW, STACK_ST_OK, StackDumpWrapperWhy, and StackValidate()\&.
.SS "\fBStackRigidOperationCodes\fP StackDestruct (\fB__overload\fP(StackRigid) ** stack)"

.PP
Free stack memory\&. 
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack to be distructed 
.RE
.PP
\fBReturns\fP
.RS 4
the outcome of the operation 
.RE
.PP

.PP
.nf
597                                                                         {
598     if (!istack_pointer_valid(stack, sizeof(stack))) {
599         return STACK_OP_NULL;
600     }
601     if (!istack_pointer_valid(*stack, sizeof(*stack))) {
602         return STACK_OP_NULL;
603     }
604     StackRigidState checks = StackValidate(*stack);
605     if (checks == STACK_ST_OK){
606         const size_t memoryNow = StackRigidMemoryUse(*stack);
607         for(char* cursor = (char*)(*stack); cursor < (char*)(*stack) + memoryNow; cursor++)
608             *cursor = 0;
609     }
610     free(*stack);
611     return STACK_OP_OK;
612 }
.fi
.PP
References STACK_OP_NULL, STACK_OP_OK, STACK_ST_OK, StackRigidMemoryUse(), and StackValidate()\&.
.PP
Referenced by main()\&.
.SS "void StackDump (\fB__overload\fP(StackRigid) * stack, const int line, const char * file, const char * why)"

.PP
Dumps debug information about the stack\&. 
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack to be dumped 
.RE
.PP

.PP
.nf
505                                                                                                   {
506     time_t rawtime = time(NULL);
507     struct tm *ptm = localtime(&rawtime);
508     
509     if (!istack_pointer_valid(stack, sizeof(stack))){
510         fprintf(stdin, "\nStack dump is impossible: NULL pointer\n");
511         return;
512     }
513     
514     FILE* output = stack->logFile;
515     if (!istack_pointer_valid(output, sizeof(output))) {
516         output = stdout;
517         printf("\nWarning! Specified dump output is inavailbale! Selecting stdout\&.\n");
518     }
519     
520     fprintf(output, "=================================\n");
521     fprintf(output, "Stack dump %s", asctime(ptm));
522     fprintf(output, "Line: %d\nFile: %s\n", line, file);
523     if (why[0] != '\0')
524     fprintf(output, "Problem: %s\n", why);
525     
526     if (istack_pointer_valid(stack, sizeof(stack))) {
527         fprintf(output, "Stack (");
528         const char *status = "ok";
529         StackRigidState checks = StackValidate(stack);
530         switch (checks) {
531             case STACK_ST_INTEGRITYERR:
532                 status = "INTEGRITY ERROR SPOTTED";
533                 break;
534             case STACK_ST_UNINITIALIZED:
535                 status = "UNINITIALIZED";
536                 break;
537             case STACK_ST_OK:
538                 status = "ok";
539                 break;
540             case STACK_ST_NULL:
541                 status = "NULL POINTER";
542                 break;
543         }
544         fprintf(output, "%s", status);
545         fprintf(output, ")");
546         fprintf(output, " [%p]: {\n", stack);
547         if (checks != STACK_ST_OK) {
548             fprintf(output, "ERROR! Stack structure was corrupted\&.\nThe data below was changed from the outside\&.\nThis can fail!\n");
549         }
550         fprintf(output, "\t         size : %lu\n", stack->size);
551         fprintf(output, "\t     capacity : %lu\n", stack->capacity);
552         fprintf(output, "\t     checkSum : %x\n", stack->checkSumVital);
553         fprintf(output, "\tcheckSumVital : %x\n", stack->checkSum);
554         
555         fprintf(output, "\tdata [%p]: {\n", stack->data);
556         if (checks == STACK_ST_OK) {
557         size_t i = 0;
558         for (i = 0; i < stack->size; i++) {
559             fprintf(output, "\t\t");
560             fprintf(output, "*[%lu] : ", i);
561             fprintf(output, "[%p] ", stack->data + i);
562             StackElementDump(stack->logFile, stack->data[i]);
563             fprintf(output, "\n");
564         }
565         fprintf(output, "\t\t _______\n");
566         if (stack->size  < stack->capacity) {
567             fprintf(output, "\t\t [%lu] : GARBAGE(", i);
568             fprintf(output, "[%p] ", stack->data + i);
569             StackElementDump(stack->logFile, stack->data[i]);
570             fprintf(output, ")\n");
571         }
572         if (stack->size + 1< stack->capacity && stack->size + 1 > stack->size) {
573             fprintf(output, "\t\t [%lu] : GARBAGE(", i + 1);
574             fprintf(output, "[%p] ", stack->data + i + 1);
575             StackElementDump(stack->logFile, stack->data[i + 1]);
576             fprintf(output, ")\n");
577         }
578         } else{
579             fprintf(output, "\t\tDATA CAN'T BE READED\n");
580         }
581         
582         fprintf(output, "\t}\n");
583         fprintf(output, "}\n");
584         
585         const size_t memory = StackRigidMemoryUse(stack);
586         fprintf(output, "Size allocated : %lu bytes\n", memory);
587         fprintf(output, "Raw Stack size : %lu bytes\n", sizeof(__overload(StackRigid)));
588         fprintf(output, "  Element size : %lu bytes\n", sizeof(StackElementType));
589         fprintf(output, "     Block end : %p\n", (char*)stack + memory);
590     }
591     fprintf(output, "=================================\n");
592     fflush(NULL);
593     
594 }
.fi
.PP
References __overload, memory, STACK_ST_INTEGRITYERR, STACK_ST_NULL, STACK_ST_OK, STACK_ST_UNINITIALIZED, StackElementDump, StackElementType, StackRigidMemoryUse(), and StackValidate()\&.
.SS "\fBStackRigidOperationCodes\fP StackPop (\fB__overload\fP(StackRigid) ** stack, \fBStackElementType\fP * value)"

.PP
Pop value from the end of the stack The operation can perform reallocations if there is too much space\&. 
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack to be distructed 
.br
\fIvalue\fP value to be pushed 
.RE
.PP
\fBReturns\fP
.RS 4
the outcome of the operation 
.RE
.PP

.PP
.nf
339                                                                                             {
340     if (!istack_pointer_valid(stack, sizeof(stack)))
341         return STACK_OP_NULL;
342     
343     StackRigidState integrityChecks = StackValidate(*stack);
344     
345     if (integrityChecks != STACK_ST_OK) {
346         StackDumpWrapperWhy(*stack, "StackPop operation spotted integrity error");
347         return STACK_OP_INTEGRITYERR;
348     }
349     
350     if((*stack)->size == 0)
351         return STACK_OP_UNDERFLOW;
352     
353     *value = (*stack)->data[(*stack)->size - 1];
354     (*stack)->size -= 1;
355     
356     __StackReallocate(stack, -1);
357     __StackUpdateChecksum(*stack);
358 
359     return STACK_OP_OK;
360 }
.fi
.PP
References __StackReallocate(), __StackUpdateChecksum(), STACK_OP_INTEGRITYERR, STACK_OP_NULL, STACK_OP_OK, STACK_OP_UNDERFLOW, STACK_ST_OK, StackDumpWrapperWhy, and StackValidate()\&.
.PP
Referenced by main()\&.
.SS "\fBStackRigidOperationCodes\fP StackPush (\fB__overload\fP(StackRigid) ** stack, \fBStackElementType\fP value)"

.PP
Push the value to the stack The operation can perform reallocations if there is not enough space\&. 
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack to be changed 
.br
\fIvalue\fP value to be pushed 
.RE
.PP
\fBReturns\fP
.RS 4
the outcome of the operation 
.RE
.PP

.PP
.nf
274                                                                                            {
275     if (!istack_pointer_valid(stack, sizeof(stack)))
276         return STACK_OP_PTRINVALID;
277     if (!istack_pointer_valid(*stack, sizeof(*stack)))
278         return STACK_OP_PTRINVALID;
279     
280     
281     StackRigidState integrityChecks = StackValidate(*stack);
282     
283     if (integrityChecks != STACK_ST_OK) {
284         StackDumpWrapperWhy(*stack, "StackPush operation spotted integrity error");
285         return STACK_OP_INTEGRITYERR;
286     }
287     
288     
289     StackRigidOperationCodes reallocResult = __StackReallocate(stack, 1);
290     
291     if (reallocResult != STACK_OP_OK) {
292         StackDumpWrapperWhy(*stack, "StackPop operation spotted integrity error during the reallocation");
293         return reallocResult;
294     }
295     
296     (*stack)->data[(*stack)->size] = value;
297     (*stack)->size += 1;
298     
299     __StackUpdateChecksum(*stack);
300     
301     if ((*stack)->size == 0) {
302         return STACK_OP_OVERFLOW;
303     }
304     return STACK_OP_OK;
305 }
.fi
.PP
References __StackReallocate(), __StackUpdateChecksum(), STACK_OP_INTEGRITYERR, STACK_OP_OK, STACK_OP_OVERFLOW, STACK_OP_PTRINVALID, STACK_ST_OK, StackDumpWrapperWhy, and StackValidate()\&.
.PP
Referenced by main()\&.
.SS "size_t StackRigidMemoryUse (\fB__overload\fP(StackRigid) * stack)"

.PP
Memory alocated for the Stack\&. 
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack to be checked 
.RE
.PP
\fBReturns\fP
.RS 4
alocated bytes 
.RE
.PP

.PP
.nf
499                                                            {
500     assert(stack);
501     return sizeof(__overload(StackRigid)) + (stack->capacity - 1) * sizeof(StackElementType);
502 }
.fi
.PP
References __overload, and StackElementType\&.
.PP
Referenced by __StackGetChecksum(), __StackReallocate(), main(), StackDestruct(), and StackDump()\&.
.SS "\fBStackRigidState\fP StackValidate (\fB__overload\fP(StackRigid) * stack)"

.PP
Perform all stack checks: checksums, general constrains\&. 
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack to be validated 
.RE
.PP
\fBReturns\fP
.RS 4
calculated state 
.RE
.PP

.PP
.nf
383                                                               {
384     if (!istack_pointer_valid(stack, sizeof(stack)))
385         return STACK_ST_NULL;
386     
387     if (stack->size > stack->capacity || stack->checkSum == 0 || stack->checkSumVital == 0)
388         return STACK_ST_INTEGRITYERR;
389     
390     #ifndef IGNORE_VALIDITY
391         uint32_t currentChecksumVital = __StackGetChecksumVital(stack);
392         if (currentChecksumVital != stack->checkSumVital || currentChecksumVital == 0)
393             return STACK_ST_INTEGRITYERR;
394         
395         uint32_t currentChecksum = __StackGetChecksum(stack);
396         if (currentChecksum != stack->checkSum || currentChecksum == 0)
397             return STACK_ST_INTEGRITYERR;
398     #endif
399 
400     return STACK_ST_OK;
401 }
.fi
.PP
References __StackGetChecksum(), __StackGetChecksumVital(), STACK_ST_INTEGRITYERR, STACK_ST_NULL, and STACK_ST_OK\&.
.PP
Referenced by main(), StackBack(), StackDestruct(), StackDump(), StackPop(), and StackPush()\&.
.SH "Variable Documentation"
.PP 
.SS "size_t added = \fBmemory\fP + (\fBcapacity\fP \- 1) * sizeof(\fBStackElementType\fP)"

.SS "\fBpointer\fP capacity = capacity"

.SS "\fBpointer\fP checkSum = 0"

.SS "\fBpointer\fP checkSumVital = 0"

.SS "\fBpointer\fP logFile"
\fBInitial value:\fP
.PP
.nf
{
     if (capacity == 0)
         capacity = 1
.fi
.SS "memory = sizeof( \fB__overload\fP(StackRigid))"

.PP
Referenced by __StackGetChecksum(), __StackGetChecksumVital(), __StackReallocate(), and StackDump()\&.
.SS "return pointer"

.SS "\fBpointer\fP size = 0"

.SH "Author"
.PP 
Generated automatically by Doxygen for StackRigid from the source code\&.
