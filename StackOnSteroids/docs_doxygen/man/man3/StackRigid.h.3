.TH "StackOnSteroids/StackRigid.h" 3 "Fri Oct 2 2020" "StackRigid" \" -*- nroff -*-
.ad l
.nh
.SH NAME
StackOnSteroids/StackRigid.h
.SH SYNOPSIS
.br
.PP
\fC#include <stdlib\&.h>\fP
.br
\fC#include <stdio\&.h>\fP
.br
\fC#include <assert\&.h>\fP
.br
\fC#include <time\&.h>\fP
.br

.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef int \fBStackElementType\fP"
.br
.RI "Element type to be used in Stack\&. "
.ti -1c
.RI "typedef struct \fBStackRigid\fP \fBStackRigid\fP"
.br
.RI "The main structure\&. "
.ti -1c
.RI "typedef enum \fBStackRigidOperationCodes\fP \fBStackRigidOperationCodes\fP"
.br
.RI "Codes returned after operations on Stack\&. "
.ti -1c
.RI "typedef enum \fBStackRigidState\fP \fBStackRigidState\fP"
.br
.RI "Codes characterizing Stack state\&. "
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBStackRigidOperationCodes\fP { \fBSTACK_OP_OK\fP, \fBSTACK_OP_UNDERFLOW\fP, \fBSTACK_OP_OVERFLOW\fP, \fBSTACK_OP_NOMEMORY\fP, \fBSTACK_OP_INTEGRITYERR\fP, \fBSTACK_OP_NULL\fP }"
.br
.RI "Codes returned after operations on Stack\&. "
.ti -1c
.RI "enum \fBStackRigidState\fP { \fBSTACK_ST_OK\fP, \fBSTACK_ST_INTEGRITYERR\fP, \fBSTACK_ST_UNINITIALIZED\fP, \fBSTACK_ST_NULL\fP }"
.br
.RI "Codes characterizing Stack state\&. "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "static uint32_t \fB__StackGetChecksum\fP (\fBStackRigid\fP *stack)"
.br
.RI "Claculates big Stack checksum\&. Uses Adler-32 method\&. "
.ti -1c
.RI "static uint32_t \fB__StackGetChecksumVital\fP (\fBStackRigid\fP *stack)"
.br
.RI "Uses Adler-32 method\&. Calculates Stack checksum only for the vital parameters\&. This is necessary because \fB__StackGetChecksum()\fP relies on capacity and size\&. If they were changed, behaviour is undefined\&. "
.ti -1c
.RI "static \fBStackRigidOperationCodes\fP \fB__StackRealocate\fP (\fBStackRigid\fP **stack, short int direction)"
.br
.RI "Realocates Stack if needed\&. "
.ti -1c
.RI "static void \fB__StackUpdateChecksum\fP (\fBStackRigid\fP *stack)"
.br
.RI "Updates Stack checksums\&. Does not take into account bytes inside the stack but outside of its last element\&. "
.ti -1c
.RI "static uint32_t \fBadlerChecksum\fP (const void *firstBlock, size_t len)"
.br
.RI "Calculates Adler-32 checksum from the firstBlock to the firstBlock + len\&. "
.ti -1c
.RI "\fBStackRigid\fP * \fBNewStackRigid\fP (const size_t capacity, FILE *logFile)"
.br
.RI "Create new stack with pre-defined capacity\&. "
.ti -1c
.RI "\fBStackRigidOperationCodes\fP \fBStackBack\fP (\fBStackRigid\fP *stack, \fBStackElementType\fP *value)"
.br
.RI "Free stack memory\&. "
.ti -1c
.RI "\fBStackRigidOperationCodes\fP \fBStackDestruct\fP (\fBStackRigid\fP **stack)"
.br
.RI "Free stack memory\&. "
.ti -1c
.RI "void \fBStackDump\fP (\fBStackRigid\fP *stack)"
.br
.RI "Dumps debug information about the stack\&. "
.ti -1c
.RI "\fBStackRigidOperationCodes\fP \fBStackPop\fP (\fBStackRigid\fP **stack, \fBStackElementType\fP *value)"
.br
.RI "Pop value from the end of the stack The operation can perform realocations if there is too much space\&. "
.ti -1c
.RI "\fBStackRigidOperationCodes\fP \fBStackPush\fP (\fBStackRigid\fP **stack, \fBStackElementType\fP value)"
.br
.RI "Push the value to the stack The operation can perform realocations if there is not enough space\&. "
.ti -1c
.RI "size_t \fBStackRigidMemoryUse\fP (\fBStackRigid\fP *stack)"
.br
.RI "Memory alocated for the Stack\&. "
.ti -1c
.RI "\fBStackRigidState\fP \fBStackValidate\fP (\fBStackRigid\fP *stack)"
.br
.RI "Perform all stack checks: checksums, general constrains\&. "
.in -1c
.SH "Typedef Documentation"
.PP 
.SS "typedef int \fBStackElementType\fP"

.PP
Element type to be used in Stack\&. 
.SS "typedef struct \fBStackRigid\fP \fBStackRigid\fP"

.PP
The main structure\&. There's no definition in the header file in order to block direct parameters access 
.SS "typedef enum \fBStackRigidOperationCodes\fP \fBStackRigidOperationCodes\fP"

.PP
Codes returned after operations on Stack\&. 
.SS "typedef enum \fBStackRigidState\fP \fBStackRigidState\fP"

.PP
Codes characterizing Stack state\&. 
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBStackRigidOperationCodes\fP"

.PP
Codes returned after operations on Stack\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fISTACK_OP_OK \fP\fP
Succesful operation\&. 
.TP
\fB\fISTACK_OP_UNDERFLOW \fP\fP
Tried to get value from the empty stack\&. 
.TP
\fB\fISTACK_OP_OVERFLOW \fP\fP
Stack overflow and new memory allocation failed\&. 
.TP
\fB\fISTACK_OP_NOMEMORY \fP\fP
No memory for stack alocations\&. 
.TP
\fB\fISTACK_OP_INTEGRITYERR \fP\fP
Stack memory was altered by some outer access\&. 
.TP
\fB\fISTACK_OP_NULL \fP\fP
Found NULL pointer during the operation\&. 
.PP
.nf
31                                      {
35     STACK_OP_OK,
39     STACK_OP_UNDERFLOW,
43     STACK_OP_OVERFLOW,
47     STACK_OP_NOMEMORY,
51     STACK_OP_INTEGRITYERR,
55     STACK_OP_NULL
56 } StackRigidOperationCodes;
.fi
.SS "enum \fBStackRigidState\fP"

.PP
Codes characterizing Stack state\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fISTACK_ST_OK \fP\fP
Stack is running as expected\&. 
.TP
\fB\fISTACK_ST_INTEGRITYERR \fP\fP
Stack was altered by some outer access\&. 
.TP
\fB\fISTACK_ST_UNINITIALIZED \fP\fP
Stack is uninitialized\&. 
.TP
\fB\fISTACK_ST_NULL \fP\fP
Found NULL pointer during the operation\&. 
.PP
.nf
62                             {
66     STACK_ST_OK,
70     STACK_ST_INTEGRITYERR,
74     STACK_ST_UNINITIALIZED,
78     STACK_ST_NULL
79 } StackRigidState;
.fi
.SH "Function Documentation"
.PP 
.SS "static uint32_t __StackGetChecksum (\fBStackRigid\fP * stack)\fC [static]\fP"

.PP
Claculates big Stack checksum\&. Uses Adler-32 method\&. 
.PP
\fBAttention\fP
.RS 4
Not for the manual use! 
.PP
.nf
* Stack memory : [ checkSum checkSumVital capacity size logFile | value 1, value 2, ..., value n || ___garbage area___]
* ________________from here ^__________________________________________________________^to here
* 
.fi
.PP
 
.RE
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack that checksums are needed to be updated 
.RE
.PP

.SS "static uint32_t __StackGetChecksumVital (\fBStackRigid\fP * stack)\fC [static]\fP"

.PP
Uses Adler-32 method\&. Calculates Stack checksum only for the vital parameters\&. This is necessary because \fB__StackGetChecksum()\fP relies on capacity and size\&. If they were changed, behaviour is undefined\&. 
.PP
\fBAttention\fP
.RS 4
Not for the manual use!
.RE
.PP
.PP
.nf
* Stack memory : [ checkSum checkSumVital capacity size logFile | value 1, value 2, ..., value n || ___garbage area___]
* ______________________________from here ^__________________^to here
* .fi
.PP
 
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack that checksums are needed to be updated 
.RE
.PP

.SS "static \fBStackRigidOperationCodes\fP __StackRealocate (\fBStackRigid\fP ** stack, short int direction)\fC [static]\fP"

.PP
Realocates Stack if needed\&. 
.PP
\fBAttention\fP
.RS 4
Not for the manual use! 
.RE
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack to be realocated 
.br
\fIdirection\fP which direction realocations are available\&. > 0 -> expand space if needed, < 0 -> shrink space if needed 
.RE
.PP

.SS "static void __StackUpdateChecksum (\fBStackRigid\fP * stack)\fC [static]\fP"

.PP
Updates Stack checksums\&. Does not take into account bytes inside the stack but outside of its last element\&. 
.PP
\fBAttention\fP
.RS 4
Not for the manual use! 
.PP
.nf
* Stack memory :  [ __stack area__ | value 1, value 2, ..., value n || ___garbage area___]
* ____________________________________________________________________^ alterations in this area are not checked
* 
.fi
.PP
 
.RE
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack that checksums are needed to be updated 
.RE
.PP

.SS "static uint32_t adlerChecksum (const void * firstBlock, size_t len)\fC [static]\fP"

.PP
Calculates Adler-32 checksum from the firstBlock to the firstBlock + len\&. 
.PP
\fBAttention\fP
.RS 4
Not for the manual use! 
.RE
.PP
\fBParameters\fP
.RS 4
\fIfirstBlock\fP first block to include to the checksum 
.br
\fIlen\fP length of byte sequence 
.RE
.PP
\fBReturns\fP
.RS 4
checksum 
.RE
.PP

.SS "\fBStackRigid\fP* NewStackRigid (const size_t capacity, FILE * logFile)"

.PP
Create new stack with pre-defined capacity\&. 
.PP
\fBParameters\fP
.RS 4
\fIcapacity\fP initial stack capacity\&. Set to 0 if yo want the stack to adopt automaticaly\&. 
.br
\fIlogFile\fP file for logging 
.RE
.PP
\fBReturns\fP
.RS 4
new stack pointer 
.RE
.PP

.PP
.nf
37                                                                 {
38     const size_t memory = sizeof(StackRigid) + (capacity - 2) * sizeof(StackElementType);
39     StackRigid* pointer = (StackRigid*)calloc(memory, 1);
40     if (pointer == NULL) {
41         return NULL;
42     }
43     
44     pointer->capacity = capacity;
45     pointer->size = 0;
46     pointer->logFile = logFile;
47     pointer->checkSum = 0;
48     pointer->checkSumVital = 0;
49     __StackUpdateChecksum(pointer);
50     return pointer;
51 }
.fi
.PP
References __StackUpdateChecksum(), StackRigid::capacity, StackRigid::checkSum, StackRigid::checkSumVital, StackRigid::logFile, and StackRigid::size\&.
.PP
Referenced by main()\&.
.SS "\fBStackRigidOperationCodes\fP StackBack (\fBStackRigid\fP * stack, \fBStackElementType\fP * value)"

.PP
Free stack memory\&. 
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack to be used 
.RE
.PP
\fBReturns\fP
.RS 4
the outcome of the operation 
.RE
.PP

.PP
.nf
123                                                                               {
124     if (stack == NULL)
125         return STACK_OP_NULL;
126     
127     StackRigidState integrityChecks = StackValidate(stack);
128     if (integrityChecks != STACK_ST_OK) {
129         StackDump(stack);
130         return STACK_OP_INTEGRITYERR;
131     }
132     
133     if(stack->size == 0)
134         return STACK_OP_UNDERFLOW;
135     
136     *value = stack->data[stack->size - 1];
137     return STACK_OP_OK;
138 }
.fi
.PP
References StackRigid::data, StackRigid::size, STACK_OP_INTEGRITYERR, STACK_OP_NULL, STACK_OP_OK, STACK_OP_UNDERFLOW, STACK_ST_OK, StackDump(), and StackValidate()\&.
.SS "\fBStackRigidOperationCodes\fP StackDestruct (\fBStackRigid\fP ** stack)"

.PP
Free stack memory\&. 
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack to be distructed 
.RE
.PP
\fBReturns\fP
.RS 4
the outcome of the operation 
.RE
.PP

.PP
.nf
365                                                            {
366     if (stack == NULL) {
367         return STACK_OP_NULL;
368     }
369     if (*stack == NULL) {
370         return STACK_OP_NULL;
371     }
372     free(*stack);
373     return STACK_OP_OK;
374 }
.fi
.PP
References STACK_OP_NULL, and STACK_OP_OK\&.
.PP
Referenced by main()\&.
.SS "void StackDump (\fBStackRigid\fP * stack)"

.PP
Dumps debug information about the stack\&. 
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack to be dumped 
.RE
.PP

.PP
.nf
297                                   {
298     time_t rawtime = time(NULL);
299     struct tm *ptm = localtime(&rawtime);
300     
301     FILE* output = stack->logFile;
302     if (output == NULL) {
303         output = stdout;
304         printf("\nWarning! Specified dump output is inavailbale! Selecting stdout\&.\n");
305     }
306     
307     fprintf(output, "=================================\n");
308     fprintf(output, "Stack dump %s", asctime(ptm));
309     
310     if (stack == NULL) {
311         fprintf(output, "\nStack dump is impossible: NULL pointer\n");
312     }else{
313         fprintf(output, "Stack (");
314         const char *status = "ok";
315         StackRigidState checks = StackValidate(stack);
316         switch (checks) {
317             case STACK_ST_INTEGRITYERR:
318                 status = "INTEGRITY ERROR SPOTTED";
319                 break;
320             case STACK_ST_UNINITIALIZED:
321                 status = "UNINITIALIZED";
322                 break;
323             case STACK_ST_OK:
324                 status = "ok";
325                 break;
326             case STACK_ST_NULL:
327                 status = "NULL POINTER";
328                 break;
329         }
330         fprintf(output, "%s", status);
331         fprintf(output, ")");
332         fprintf(output, " [%p]: {\n", stack);
333         if (checks == STACK_ST_INTEGRITYERR) {
334             fprintf(output, "ERROR! Stack structure was corrupted\&. The data below was changed from the outside\&.\n");
335         }
336         fprintf(output, "\t    size : %lu\n", stack->size);
337         fprintf(output, "\tcapacity : %lu\n", stack->capacity);
338         fprintf(output, "\tcheckSum : %x\n", stack->checkSum);
339         
340         fprintf(output, "\tdata [%p]: {\n", stack->data);
341         size_t i = 0;
342         for (i = 0; i < stack->size; i++) {
343             fprintf(output, "\t\t");
344             fprintf(output, "*[%lu] : %d\n", i, stack->data[i]);
345         }
346         fprintf(output, "\t\t _______\n");
347         if (stack->size < stack->capacity) {
348             fprintf(output, "\t\t [%lu] : GARBAGE(%d)\n", i + 1, stack->data[i + 1]);
349         }
350         if (stack->size + 1 < stack->capacity && stack->size + 1 > stack->size) {
351             fprintf(output, "\t\t [%lu] : GARBAGE(%d)\n", i + 2, stack->data[i + 2]);
352         }
353         fprintf(output, "\t}\n");
354         fprintf(output, "}\n");
355         
356         const size_t memory = StackRigidMemoryUse(stack);
357         fprintf(output, "Size allocated : %lu bytes\n", memory);
358         fprintf(output, "Raw Stack size : %lu bytes\n", sizeof(StackRigid));
359         fprintf(output, "  Element size : %lu bytes\n", sizeof(StackElementType));
360         fprintf(output, "     Block end : %p\n", (char*)stack + memory);
361     }
362     fprintf(output, "=================================\n");
363 }
.fi
.PP
References StackRigid::capacity, StackRigid::checkSum, StackRigid::data, StackRigid::logFile, StackRigid::size, STACK_ST_INTEGRITYERR, STACK_ST_NULL, STACK_ST_OK, STACK_ST_UNINITIALIZED, StackRigidMemoryUse(), and StackValidate()\&.
.PP
Referenced by main(), StackBack(), StackPop(), and StackPush()\&.
.SS "\fBStackRigidOperationCodes\fP StackPop (\fBStackRigid\fP ** stack, \fBStackElementType\fP * value)"

.PP
Pop value from the end of the stack The operation can perform realocations if there is too much space\&. 
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack to be distructed 
.br
\fIvalue\fP value to be pushed 
.RE
.PP
\fBReturns\fP
.RS 4
the outcome of the operation 
.RE
.PP

.PP
.nf
90                                                                                {
91     #ifdef DEBUGSPEED
92         clock_t start = clock();
93     #endif
94     
95     if (stack == NULL)
96         return STACK_OP_NULL;
97     
98     StackRigidState integrityChecks = StackValidate(*stack);
99     if (integrityChecks != STACK_ST_OK) {
100         StackDump(*stack);
101         return STACK_OP_INTEGRITYERR;
102     }
103     
104     if((*stack)->size == 0)
105         return STACK_OP_UNDERFLOW;
106     
107     *value = (*stack)->data[(*stack)->size - 1];
108     (*stack)->size -= 1;
109     
110     __StackRealocate(stack, -1);
111     __StackUpdateChecksum(*stack);
112     
113     #ifdef DEBUGSPEED
114         clock_t end = clock();
115         double elapsed = (double)(end - start) / CLOCKS_PER_SEC;
116         StackRigidAvgTimes[3] = StackRigidAvgTimes[3] * (movingAverageBetta) + elapsed * (1 - movingAverageBetta);
117     #endif
118     
119     return STACK_OP_OK;
120 }
.fi
.PP
References __StackRealocate(), __StackUpdateChecksum(), movingAverageBetta, STACK_OP_INTEGRITYERR, STACK_OP_NULL, STACK_OP_OK, STACK_OP_UNDERFLOW, STACK_ST_OK, StackDump(), StackRigidAvgTimes, and StackValidate()\&.
.PP
Referenced by main()\&.
.SS "\fBStackRigidOperationCodes\fP StackPush (\fBStackRigid\fP ** stack, \fBStackElementType\fP value)"

.PP
Push the value to the stack The operation can perform realocations if there is not enough space\&. 
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack to be changed 
.br
\fIvalue\fP value to be pushed 
.RE
.PP
\fBReturns\fP
.RS 4
the outcome of the operation 
.RE
.PP

.PP
.nf
54                                                                                {
55     #ifdef DEBUGSPEED
56         clock_t start = clock();
57     #endif
58     if (stack == NULL)
59         return STACK_OP_NULL;
60     
61     StackRigidState integrityChecks = StackValidate(*stack);
62     if (integrityChecks != STACK_ST_OK) {
63         StackDump(*stack);
64         return STACK_OP_INTEGRITYERR;
65     }
66     
67     StackRigidOperationCodes realocResult = __StackRealocate(stack, 1);
68     if (realocResult != STACK_OP_OK) {
69         StackDump(*stack);
70         return realocResult;
71     }
72     
73     (*stack)->data[(*stack)->size] = value;
74     (*stack)->size += 1;
75     
76     __StackUpdateChecksum(*stack);
77     
78     if ((*stack)->size == 0) {
79         return STACK_OP_OVERFLOW;
80     }
81     #ifdef DEBUGSPEED
82         clock_t end = clock();
83         double elapsed = (double)(end - start) / CLOCKS_PER_SEC;
84         StackRigidAvgTimes[2] = StackRigidAvgTimes[2] * (movingAverageBetta) + elapsed * (1 - movingAverageBetta);
85     #endif
86     return STACK_OP_OK;
87 }
.fi
.PP
References __StackRealocate(), __StackUpdateChecksum(), movingAverageBetta, STACK_OP_INTEGRITYERR, STACK_OP_NULL, STACK_OP_OK, STACK_OP_OVERFLOW, STACK_ST_OK, StackDump(), StackRigidAvgTimes, and StackValidate()\&.
.PP
Referenced by main()\&.
.SS "size_t StackRigidMemoryUse (\fBStackRigid\fP * stack)"

.PP
Memory alocated for the Stack\&. 
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack to be checked 
.RE
.PP
\fBReturns\fP
.RS 4
alocated bytes 
.RE
.PP

.PP
.nf
291                                               {
292     assert(stack);
293     return sizeof(StackRigid) + (stack->capacity - 2) * sizeof(StackElementType);
294 }
.fi
.PP
References StackRigid::capacity\&.
.PP
Referenced by __StackGetChecksum(), __StackRealocate(), main(), and StackDump()\&.
.SS "\fBStackRigidState\fP StackValidate (\fBStackRigid\fP * stack)"

.PP
Perform all stack checks: checksums, general constrains\&. 
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack to be validated 
.RE
.PP
\fBReturns\fP
.RS 4
calculated state 
.RE
.PP

.PP
.nf
141                                                  {
142     #ifdef DEBUGSPEED
143         clock_t start = clock();
144     #endif
145     
146     if (stack == NULL)
147         return STACK_ST_NULL;
148     
149     if (stack->size > stack->capacity || stack->checkSum == 0 || stack->checkSumVital == 0)
150         return STACK_ST_INTEGRITYERR;
151     
152     uint32_t currentChecksumVital = __StackGetChecksumVital(stack);
153     if (currentChecksumVital != stack->checkSumVital || currentChecksumVital == 0)
154         return STACK_ST_INTEGRITYERR;
155     
156     uint32_t currentChecksum = __StackGetChecksum(stack);
157     if (currentChecksum != stack->checkSum || currentChecksum == 0)
158         return STACK_ST_INTEGRITYERR;
159     
160     #ifdef DEBUGSPEED
161         clock_t end = clock();
162         double elapsed = (double)(end - start) / CLOCKS_PER_SEC;
163         StackRigidAvgTimes[1] = StackRigidAvgTimes[1] * (movingAverageBetta) + elapsed * (1 - movingAverageBetta);
164     #endif
165     return STACK_ST_OK;
166 }
.fi
.PP
References __StackGetChecksum(), __StackGetChecksumVital(), StackRigid::capacity, StackRigid::checkSum, StackRigid::checkSumVital, movingAverageBetta, StackRigid::size, STACK_ST_INTEGRITYERR, STACK_ST_NULL, STACK_ST_OK, and StackRigidAvgTimes\&.
.PP
Referenced by main(), StackBack(), StackDump(), StackPop(), and StackPush()\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for StackRigid from the source code\&.
