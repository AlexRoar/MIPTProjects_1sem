.TH "StackOnSteroids/StackRigid.h" 3 "Mon Oct 5 2020" "StackRigid" \" -*- nroff -*-
.ad l
.nh
.SH NAME
StackOnSteroids/StackRigid.h
.SH SYNOPSIS
.br
.PP
\fC#include <stdlib\&.h>\fP
.br
\fC#include <stdio\&.h>\fP
.br
\fC#include <assert\&.h>\fP
.br
\fC#include <time\&.h>\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fB__overload\fP(FUNC)   \fBEVALUATOR\fP(FUNC, \fBStackElementType\fP)"
.br
.ti -1c
.RI "#define \fBEVALUATOR\fP(x,  y)   \fBPASTER\fP(x,y)"
.br
.ti -1c
.RI "#define \fBPASTER\fP(x,  y)   x ## _ ## y"
.br
.ti -1c
.RI "#define \fBStackElementDump\fP(FILE,  VALUE)   {fprintf(FILE, '%d', VALUE);}"
.br
.RI "Default element dump instruction\&. "
.ti -1c
.RI "#define \fBStackElementType\fP   int"
.br
.RI "By default, it would be stack of ints\&. "
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef enum \fBStackRigidOperationCodes\fP \fBStackRigidOperationCodes\fP"
.br
.RI "Codes returned after operations on Stack\&. "
.ti -1c
.RI "typedef enum \fBStackRigidState\fP \fBStackRigidState\fP"
.br
.RI "Codes characterizing Stack state\&. "
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBStackRigidOperationCodes\fP { \fBSTACK_OP_OK\fP, \fBSTACK_OP_UNDERFLOW\fP, \fBSTACK_OP_OVERFLOW\fP, \fBSTACK_OP_NOMEMORY\fP, \fBSTACK_OP_INTEGRITYERR\fP, \fBSTACK_OP_NULL\fP }"
.br
.RI "Codes returned after operations on Stack\&. "
.ti -1c
.RI "enum \fBStackRigidState\fP { \fBSTACK_ST_OK\fP, \fBSTACK_ST_INTEGRITYERR\fP, \fBSTACK_ST_UNINITIALIZED\fP, \fBSTACK_ST_NULL\fP }"
.br
.RI "Codes characterizing Stack state\&. "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "struct \fB__overload\fP (StackRigid) *__overload(NewStackRigid)(const size_t \fBcapacity\fP = ( __overload(StackRigid)*)calloc(memory, 1)"
.br
.RI "Create new stack with pre-defined capacity\&. "
.ti -1c
.RI "static uint32_t \fB__StackGetChecksum\fP (\fB__overload\fP(StackRigid) *stack)"
.br
.RI "Claculates big Stack checksum\&. Uses Adler-32 method\&. "
.ti -1c
.RI "static uint32_t \fB__StackGetChecksumVital\fP (\fB__overload\fP(StackRigid) *stack)"
.br
.RI "Uses Adler-32 method\&. Calculates Stack checksum only for the vital parameters\&. This is necessary because \fB__StackGetChecksum()\fP relies on capacity and size\&. If they were changed, behaviour is undefined\&. "
.ti -1c
.RI "static \fBStackRigidOperationCodes\fP \fB__StackRealocate\fP (\fB__overload\fP(StackRigid) **stack, short int direction)"
.br
.RI "Realocates Stack if needed\&. "
.ti -1c
.RI "static void \fB__StackUpdateChecksum\fP (\fB__overload\fP(StackRigid) *stack)"
.br
.RI "Updates Stack checksums\&. Does not take into account bytes inside the stack but outside of its last element\&. "
.ti -1c
.RI "\fB__StackUpdateChecksum\fP (\fBpointer\fP)"
.br
.ti -1c
.RI "static uint32_t \fBadlerChecksum\fP (const void *firstBlock, size_t len)"
.br
.RI "Calculates Adler-32 checksum from the firstBlock to the firstBlock + len\&. "
.ti -1c
.RI "\fBif\fP (\fBpointer\fP==NULL)"
.br
.ti -1c
.RI "\fBStackRigidOperationCodes\fP \fBStackBack\fP (\fB__overload\fP(StackRigid) *stack, \fBStackElementType\fP *value)"
.br
.RI "Free stack memory\&. "
.ti -1c
.RI "\fBStackRigidOperationCodes\fP \fBStackDestruct\fP (\fB__overload\fP(StackRigid) **stack)"
.br
.RI "Free stack memory\&. "
.ti -1c
.RI "void \fBStackDump\fP (\fB__overload\fP(StackRigid) *stack)"
.br
.RI "Dumps debug information about the stack\&. "
.ti -1c
.RI "\fBStackRigidOperationCodes\fP \fBStackPop\fP (\fB__overload\fP(StackRigid) **stack, \fBStackElementType\fP *value)"
.br
.RI "Pop value from the end of the stack The operation can perform realocations if there is too much space\&. "
.ti -1c
.RI "\fBStackRigidOperationCodes\fP \fBStackPush\fP (\fB__overload\fP(StackRigid) **stack, \fBStackElementType\fP value)"
.br
.RI "Push the value to the stack The operation can perform realocations if there is not enough space\&. "
.ti -1c
.RI "size_t \fBStackRigidMemoryUse\fP (\fB__overload\fP(StackRigid) *stack)"
.br
.RI "Memory alocated for the Stack\&. "
.ti -1c
.RI "\fBStackRigidState\fP \fBStackValidate\fP (\fB__overload\fP(StackRigid) *stack)"
.br
.RI "Perform all stack checks: checksums, general constrains\&. "
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBpointer\fP \fBcapacity\fP = capacity"
.br
.ti -1c
.RI "\fBpointer\fP \fBcheckSum\fP = 0"
.br
.ti -1c
.RI "\fBpointer\fP \fBcheckSumVital\fP = 0"
.br
.ti -1c
.RI "FILE * \fBlogFile\fP"
.br
.ti -1c
.RI "return \fBpointer\fP"
.br
.ti -1c
.RI "\fBpointer\fP \fBsize\fP = 0"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define __overload(FUNC)   \fBEVALUATOR\fP(FUNC, \fBStackElementType\fP)"

.SS "#define EVALUATOR(x, y)   \fBPASTER\fP(x,y)"

.SS "#define PASTER(x, y)   x ## _ ## y"

.SS "#define StackElementDump(FILE, VALUE)   {fprintf(FILE, '%d', VALUE);}"

.PP
Default element dump instruction\&. 
.SS "#define StackElementType   int"

.PP
By default, it would be stack of ints\&. 
.SH "Typedef Documentation"
.PP 
.SS "typedef enum \fBStackRigidOperationCodes\fP \fBStackRigidOperationCodes\fP"

.PP
Codes returned after operations on Stack\&. 
.SS "typedef enum \fBStackRigidState\fP \fBStackRigidState\fP"

.PP
Codes characterizing Stack state\&. 
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBStackRigidOperationCodes\fP"

.PP
Codes returned after operations on Stack\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fISTACK_OP_OK \fP\fP
Succesful operation\&. 
.TP
\fB\fISTACK_OP_UNDERFLOW \fP\fP
Tried to get value from the empty stack\&. 
.TP
\fB\fISTACK_OP_OVERFLOW \fP\fP
Stack overflow and new memory allocation failed\&. 
.TP
\fB\fISTACK_OP_NOMEMORY \fP\fP
No memory for stack alocations\&. 
.TP
\fB\fISTACK_OP_INTEGRITYERR \fP\fP
Stack memory was altered by some outer access\&. 
.TP
\fB\fISTACK_OP_NULL \fP\fP
Found NULL pointer during the operation\&. 
.PP
.nf
57                                      {
61     STACK_OP_OK,
65     STACK_OP_UNDERFLOW,
69     STACK_OP_OVERFLOW,
73     STACK_OP_NOMEMORY,
77     STACK_OP_INTEGRITYERR,
81     STACK_OP_NULL
82 } StackRigidOperationCodes;
.fi
.SS "enum \fBStackRigidState\fP"

.PP
Codes characterizing Stack state\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fISTACK_ST_OK \fP\fP
Stack is running as expected\&. 
.TP
\fB\fISTACK_ST_INTEGRITYERR \fP\fP
Stack was altered by some outer access\&. 
.TP
\fB\fISTACK_ST_UNINITIALIZED \fP\fP
Stack is uninitialized\&. 
.TP
\fB\fISTACK_ST_NULL \fP\fP
Found NULL pointer during the operation\&. 
.PP
.nf
88                             {
92     STACK_ST_OK,
96     STACK_ST_INTEGRITYERR,
100     STACK_ST_UNINITIALIZED,
104     STACK_ST_NULL
105 } StackRigidState;
.fi
.SH "Function Documentation"
.PP 
.SS "__overload (StackRigid) = ( __overload(StackRigid)*)calloc(memory, 1)"

.PP
Create new stack with pre-defined capacity\&. 
.PP
\fBParameters\fP
.RS 4
\fIcapacity\fP initial stack capacity\&. Set to 0 if you want the stack to adopt automaticaly\&. 
.br
\fIlogFile\fP file for logging 
.RE
.PP
\fBReturns\fP
.RS 4
new stack pointer 
.RE
.PP

.PP
.nf
111                               {
112     int32_t checkSum;
113     uint32_t checkSumVital;
114     size_t capacity;
115     size_t size;
116     FILE* logFile;
117     StackElementType data[1];
118 };
.fi
.SS "static uint32_t __StackGetChecksum (\fB__overload\fP(StackRigid) * stack)\fC [static]\fP"

.PP
Claculates big Stack checksum\&. Uses Adler-32 method\&. 
.PP
\fBAttention\fP
.RS 4
Not for the manual use! 
.PP
.nf
* Stack memory : [ checkSum checkSumVital capacity size logFile | value 1, value 2, ..., value n || ___garbage area___]
* Release:
* ________________from here ^__________________________________________________________^to here
* Debug:
* ________________from here ^______________________________________________________________________________^to here
* 
.fi
.PP
 
.RE
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack that checksums are needed to be updated 
.RE
.PP

.PP
.nf
387                                                                    {
388     assert(stack);
389     
390     void* firstBlock = (char*)stack + sizeof(stack->checkSum);
391     
392     // Memory used by Stack excluding checkSum and free space
393     #ifndef DEBUG
394         const size_t memory = StackRigidMemoryUse(stack) - sizeof(stack->checkSum) - (stack->capacity - stack->size) * sizeof(StackElementType);
395     #endif
396     #ifdef DEBUG
397         const size_t memory = StackRigidMemoryUse(stack) - sizeof(stack->checkSum);
398     #endif
399     
400     if (stack->size > stack->capacity) {
401         return 0;
402     }
403     return adlerChecksum(firstBlock, memory);
404 }
.fi
.PP
References adlerChecksum(), StackElementType, and StackRigidMemoryUse()\&.
.PP
Referenced by __StackUpdateChecksum(), and StackValidate()\&.
.SS "static uint32_t __StackGetChecksumVital (\fB__overload\fP(StackRigid) * stack)\fC [static]\fP"

.PP
Uses Adler-32 method\&. Calculates Stack checksum only for the vital parameters\&. This is necessary because \fB__StackGetChecksum()\fP relies on capacity and size\&. If they were changed, behaviour is undefined\&. 
.PP
\fBAttention\fP
.RS 4
Not for the manual use!
.RE
.PP
.PP
.nf
* Stack memory : [ checkSum checkSumVital capacity size logFile | value 1, value 2, ..., value n || ___garbage area___]
* ______________________________from here ^__________________^to here
* .fi
.PP
 
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack that checksums are needed to be updated 
.RE
.PP

.PP
.nf
374                                                                         {
375     assert(stack);
376     
377     void* firstBlock = (char*)stack + sizeof(stack->checkSum) + sizeof(stack->checkSumVital);
378     
379     const size_t memory = (char*)(stack->data) - (char*)(firstBlock);
380     if (stack->size > stack->capacity) {
381         return 0;
382     }
383     return adlerChecksum(firstBlock, memory);
384 }
.fi
.PP
References adlerChecksum()\&.
.PP
Referenced by __StackUpdateChecksum(), and StackValidate()\&.
.SS "static \fBStackRigidOperationCodes\fP __StackRealocate (\fB__overload\fP(StackRigid) ** stack, short int direction)\fC [static]\fP"

.PP
Realocates Stack if needed\&. 
.PP
\fBAttention\fP
.RS 4
Not for the manual use! 
.RE
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack to be realocated 
.br
\fIdirection\fP which direction realocations are available\&. > 0 -> expand space if needed, < 0 -> shrink space if needed 
.RE
.PP

.PP
.nf
407                                                                                                        {
408     if ((*stack)->capacity == 0) {
409         (*stack)->capacity = 16;
410         
411         const size_t memory = StackRigidMemoryUse(*stack);
412         
413          __overload(StackRigid)* newStack = ( __overload(StackRigid)*) realloc((*stack), memory);
414         if (newStack == NULL)
415             return STACK_OP_NOMEMORY;
416         
417         (*stack) = newStack;
418     }else if(((*stack)->capacity <= (*stack)->size) && direction > 0) {
419         // Up realocation
420         size_t newCapacity = (*stack)->size * 2;
421         
422         if (newCapacity <= (*stack)->size) { //   If we exceeded size_t range
423             newCapacity = (*stack)->size + 16; // Try to add 16 free spaces
424             if (newCapacity < (*stack)->size) //  Even if in this case we still exceed size_t
425                 return STACK_OP_OVERFLOW;
426         }
427         
428         const size_t memoryNow = StackRigidMemoryUse(*stack);
429         const size_t memoryNew = sizeof(__overload(StackRigid)) + (newCapacity - 1) * sizeof(StackElementType);
430         
431         if (memoryNew >= memoryNow) {
432              __overload(StackRigid)* newStack = ( __overload(StackRigid)*) realloc((*stack), memoryNew);
433             if (newStack == NULL)
434                 return STACK_OP_NOMEMORY;
435             
436             (*stack) = newStack;
437         }else{
438             return STACK_OP_OVERFLOW; // Exceded size_t memory
439         }
440         (*stack)->capacity = newCapacity;
441         
442     }else if (((*stack)->capacity / 2\&.2 > (*stack)->size) && direction < 0) {
443         // Down realocation
444         size_t newCapacity = (*stack)->capacity / 2\&.2;
445         
446         const size_t memoryNow = StackRigidMemoryUse(*stack);
447         const size_t memoryNew = sizeof(__overload(StackRigid)) + (newCapacity - 1) * sizeof(StackElementType);
448         
449         if (memoryNew <= memoryNow) {
450              __overload(StackRigid)* newStack = ( __overload(StackRigid)*) realloc((*stack), memoryNew);
451             if (newStack == NULL)
452                 return STACK_OP_NOMEMORY;
453             
454             (*stack) = newStack;
455             (*stack)->capacity = newCapacity;
456         }else
457             return STACK_OP_OVERFLOW; // Exceded size_t memory
458     }
459     return STACK_OP_OK;
460 }
.fi
.PP
References __overload, STACK_OP_NOMEMORY, STACK_OP_OK, STACK_OP_OVERFLOW, StackElementType, and StackRigidMemoryUse()\&.
.PP
Referenced by StackPop(), and StackPush()\&.
.SS "static void __StackUpdateChecksum (\fB__overload\fP(StackRigid) * stack)\fC [static]\fP"

.PP
Updates Stack checksums\&. Does not take into account bytes inside the stack but outside of its last element\&. 
.PP
\fBAttention\fP
.RS 4
Not for the manual use! 
.PP
.nf
* Stack memory :  [ __stack area__ | value 1, value 2, ..., value n || ___garbage area___]
* ____________________________________________________________________^ alterations in this area are not checked
* 
.fi
.PP
 
.RE
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack that checksums are needed to be updated 
.RE
.PP

.PP
.nf
365                                                                   {
366     assert(stack);
367 
368     stack->checkSumVital = __StackGetChecksumVital(stack);
369     stack->checkSum = __StackGetChecksum(stack);
370 
371 }
.fi
.PP
References __StackGetChecksum(), and __StackGetChecksumVital()\&.
.PP
Referenced by StackPop(), and StackPush()\&.
.SS "__StackUpdateChecksum (\fBpointer\fP)"

.SS "static uint32_t adlerChecksum (const void * firstBlock, size_t len)\fC [static]\fP"

.PP
Calculates Adler-32 checksum from the firstBlock to the firstBlock + len\&. 
.PP
\fBAttention\fP
.RS 4
Not for the manual use! 
.RE
.PP
\fBParameters\fP
.RS 4
\fIfirstBlock\fP first block to include to the checksum 
.br
\fIlen\fP length of byte sequence 
.RE
.PP
\fBReturns\fP
.RS 4
checksum 
.RE
.PP

.PP
.nf
43                                                                   {
44     uint32_t a = 1, b = 0;
45     const uint32_t MOD_ADLER = 65521;
46     for (size_t index = 0; index < len; ++index) {
47         a = (a + ((char*)firstBlock)[index]) % MOD_ADLER;
48         b = (b + a) % MOD_ADLER;
49     }
50     return (b << 16) | a;
51 }
.fi
.PP
Referenced by __StackGetChecksum(), and __StackGetChecksumVital()\&.
.SS "if (\fBpointer\fP = \fC= NULL\fP)"

.PP
.nf
285                          {
286         return NULL;
287     }
.fi
.SS "\fBStackRigidOperationCodes\fP StackBack (\fB__overload\fP(StackRigid) * stack, \fBStackElementType\fP * value)"

.PP
Free stack memory\&. 
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack to be used 
.RE
.PP
\fBReturns\fP
.RS 4
the outcome of the operation 
.RE
.PP

.PP
.nf
325                                                                                            {
326     if (stack == NULL)
327         return STACK_OP_NULL;
328     
329     
330     StackRigidState integrityChecks = StackValidate(stack);
331     
332     if (integrityChecks != STACK_ST_OK) {
333         StackDump(stack);
334         return STACK_OP_INTEGRITYERR;
335     }
336     
337     if(stack->size == 0)
338         return STACK_OP_UNDERFLOW;
339     
340     *value = stack->data[stack->size - 1];
341     return STACK_OP_OK;
342 }
.fi
.PP
References STACK_OP_INTEGRITYERR, STACK_OP_NULL, STACK_OP_OK, STACK_OP_UNDERFLOW, STACK_ST_OK, StackDump(), and StackValidate()\&.
.SS "\fBStackRigidOperationCodes\fP StackDestruct (\fB__overload\fP(StackRigid) ** stack)"

.PP
Free stack memory\&. 
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack to be distructed 
.RE
.PP
\fBReturns\fP
.RS 4
the outcome of the operation 
.RE
.PP

.PP
.nf
547                                                                         {
548     if (stack == NULL) {
549         return STACK_OP_NULL;
550     }
551     if (*stack == NULL) {
552         return STACK_OP_NULL;
553     }
554     free(*stack);
555     return STACK_OP_OK;
556 }
.fi
.PP
References STACK_OP_NULL, and STACK_OP_OK\&.
.PP
Referenced by main()\&.
.SS "void StackDump (\fB__overload\fP(StackRigid) * stack)"

.PP
Dumps debug information about the stack\&. 
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack to be dumped 
.RE
.PP

.PP
.nf
468                                                {
469     time_t rawtime = time(NULL);
470     struct tm *ptm = localtime(&rawtime);
471     
472     FILE* output = stack->logFile;
473     if (output == NULL) {
474         output = stdout;
475         printf("\nWarning! Specified dump output is inavailbale! Selecting stdout\&.\n");
476     }
477     
478     fprintf(output, "=================================\n");
479     fprintf(output, "Stack dump %s", asctime(ptm));
480     
481     if (stack == NULL) {
482         fprintf(output, "\nStack dump is impossible: NULL pointer\n");
483     }else{
484         fprintf(output, "Stack (");
485         const char *status = "ok";
486         StackRigidState checks = StackValidate(stack);
487         switch (checks) {
488             case STACK_ST_INTEGRITYERR:
489                 status = "INTEGRITY ERROR SPOTTED";
490                 break;
491             case STACK_ST_UNINITIALIZED:
492                 status = "UNINITIALIZED";
493                 break;
494             case STACK_ST_OK:
495                 status = "ok";
496                 break;
497             case STACK_ST_NULL:
498                 status = "NULL POINTER";
499                 break;
500         }
501         fprintf(output, "%s", status);
502         fprintf(output, ")");
503         fprintf(output, " [%p]: {\n", stack);
504         if (checks == STACK_ST_INTEGRITYERR) {
505             fprintf(output, "ERROR! Stack structure was corrupted\&. The data below was changed from the outside\&.\n");
506         }
507         fprintf(output, "\t         size : %lu\n", stack->size);
508         fprintf(output, "\t     capacity : %lu\n", stack->capacity);
509         fprintf(output, "\t     checkSum : %x\n", stack->checkSumVital);
510         fprintf(output, "\tcheckSumVital : %x\n", stack->checkSum);
511         
512         fprintf(output, "\tdata [%p]: {\n", stack->data);
513         size_t i = 0;
514         for (i = 0; i < stack->size; i++) {
515             fprintf(output, "\t\t");
516             fprintf(output, "*[%lu] : ", i);
517             fprintf(output, "[%p] ", stack->data + i);
518             StackElementDump(stack->logFile, stack->data[i]);
519             fprintf(output, "\n");
520         }
521         fprintf(output, "\t\t _______\n");
522         if (stack->size < stack->capacity) {
523             fprintf(output, "\t\t [%lu] : GARBAGE(", i + 1);
524             fprintf(output, "[%p] ", stack->data + i + 1);
525             StackElementDump(stack->logFile, stack->data[i + 1]);
526             fprintf(output, ")\n");
527         }
528         if (stack->size + 1 < stack->capacity && stack->size + 1 > stack->size) {
529             fprintf(output, "\t\t [%lu] : GARBAGE(", i + 2);
530             fprintf(output, "[%p] ", stack->data + i + 2);
531             StackElementDump(stack->logFile, stack->data[i + 2]);
532             fprintf(output, ")\n");
533         }
534         fprintf(output, "\t}\n");
535         fprintf(output, "}\n");
536         
537         const size_t memory = StackRigidMemoryUse(stack);
538         fprintf(output, "Size allocated : %lu bytes\n", memory);
539         fprintf(output, "Raw Stack size : %lu bytes\n", sizeof(__overload(StackRigid)));
540         fprintf(output, "  Element size : %lu bytes\n", sizeof(StackElementType));
541         fprintf(output, "     Block end : %p\n", (char*)stack + memory);
542     }
543     fprintf(output, "=================================\n");
544 }
.fi
.PP
References __overload, STACK_ST_INTEGRITYERR, STACK_ST_NULL, STACK_ST_OK, STACK_ST_UNINITIALIZED, StackElementDump, StackElementType, StackRigidMemoryUse(), and StackValidate()\&.
.PP
Referenced by main(), StackBack(), StackPop(), and StackPush()\&.
.SS "\fBStackRigidOperationCodes\fP StackPop (\fB__overload\fP(StackRigid) ** stack, \fBStackElementType\fP * value)"

.PP
Pop value from the end of the stack The operation can perform realocations if there is too much space\&. 
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack to be distructed 
.br
\fIvalue\fP value to be pushed 
.RE
.PP
\fBReturns\fP
.RS 4
the outcome of the operation 
.RE
.PP

.PP
.nf
300                                                                                             {
301     if (stack == NULL)
302         return STACK_OP_NULL;
303     
304     
305     StackRigidState integrityChecks = StackValidate(*stack);
306     
307     if (integrityChecks != STACK_ST_OK) {
308         StackDump(*stack);
309         return STACK_OP_INTEGRITYERR;
310     }
311     
312     if((*stack)->size == 0)
313         return STACK_OP_UNDERFLOW;
314     
315     *value = (*stack)->data[(*stack)->size - 1];
316     (*stack)->size -= 1;
317     
318     __StackRealocate(stack, -1);
319     __StackUpdateChecksum(*stack);
320 
321     return STACK_OP_OK;
322 }
.fi
.PP
References __StackRealocate(), __StackUpdateChecksum(), STACK_OP_INTEGRITYERR, STACK_OP_NULL, STACK_OP_OK, STACK_OP_UNDERFLOW, STACK_ST_OK, StackDump(), and StackValidate()\&.
.PP
Referenced by main()\&.
.SS "\fBStackRigidOperationCodes\fP StackPush (\fB__overload\fP(StackRigid) ** stack, \fBStackElementType\fP value)"

.PP
Push the value to the stack The operation can perform realocations if there is not enough space\&. 
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack to be changed 
.br
\fIvalue\fP value to be pushed 
.RE
.PP
\fBReturns\fP
.RS 4
the outcome of the operation 
.RE
.PP

.PP
.nf
248                                                                                            {
249     if (stack == NULL)
250         return STACK_OP_NULL;
251     
252     
253     StackRigidState integrityChecks = StackValidate(*stack);
254     
255     if (integrityChecks != STACK_ST_OK) {
256         StackDump(*stack);
257         return STACK_OP_INTEGRITYERR;
258     }
259     
260     
261     StackRigidOperationCodes realocResult = __StackRealocate(stack, 1);
262     
263     if (realocResult != STACK_OP_OK) {
264         StackDump(*stack);
265         return realocResult;
266     }
267     
268     (*stack)->data[(*stack)->size] = value;
269     (*stack)->size += 1;
270     
271     __StackUpdateChecksum(*stack);
272     
273     if ((*stack)->size == 0) {
274         return STACK_OP_OVERFLOW;
275     }
276     return STACK_OP_OK;
277 }
.fi
.PP
References __StackRealocate(), __StackUpdateChecksum(), STACK_OP_INTEGRITYERR, STACK_OP_NULL, STACK_OP_OK, STACK_OP_OVERFLOW, STACK_ST_OK, StackDump(), and StackValidate()\&.
.PP
Referenced by main()\&.
.SS "size_t StackRigidMemoryUse (\fB__overload\fP(StackRigid) * stack)"

.PP
Memory alocated for the Stack\&. 
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack to be checked 
.RE
.PP
\fBReturns\fP
.RS 4
alocated bytes 
.RE
.PP

.PP
.nf
462                                                            {
463     assert(stack);
464     return sizeof(__overload(StackRigid)) + (stack->capacity - 1) * sizeof(StackElementType);
465 }
.fi
.PP
References __overload, and StackElementType\&.
.PP
Referenced by __StackGetChecksum(), __StackRealocate(), main(), and StackDump()\&.
.SS "\fBStackRigidState\fP StackValidate (\fB__overload\fP(StackRigid) * stack)"

.PP
Perform all stack checks: checksums, general constrains\&. 
.PP
\fBParameters\fP
.RS 4
\fIstack\fP Stack to be validated 
.RE
.PP
\fBReturns\fP
.RS 4
calculated state 
.RE
.PP

.PP
.nf
345                                                               {
346     if (stack == NULL)
347         return STACK_ST_NULL;
348     
349     if (stack->size > stack->capacity || stack->checkSum == 0 || stack->checkSumVital == 0)
350         return STACK_ST_INTEGRITYERR;
351     
352     uint32_t currentChecksumVital = __StackGetChecksumVital(stack);
353     if (currentChecksumVital != stack->checkSumVital || currentChecksumVital == 0)
354         return STACK_ST_INTEGRITYERR;
355     
356     uint32_t currentChecksum = __StackGetChecksum(stack);
357     if (currentChecksum != stack->checkSum || currentChecksum == 0)
358         return STACK_ST_INTEGRITYERR;
359     
360 
361     return STACK_ST_OK;
362 }
.fi
.PP
References __StackGetChecksum(), __StackGetChecksumVital(), STACK_ST_INTEGRITYERR, STACK_ST_NULL, and STACK_ST_OK\&.
.PP
Referenced by main(), StackBack(), StackDump(), StackPop(), and StackPush()\&.
.SH "Variable Documentation"
.PP 
.SS "\fBpointer\fP capacity = capacity"

.SS "\fBpointer\fP checkSum = 0"

.SS "\fBpointer\fP checkSumVital = 0"

.SS "\fBpointer\fP logFile"
\fBInitial value:\fP
.PP
.nf
{
    const size_t memory = sizeof( __overload(StackRigid)) + (capacity - 1) * sizeof(StackElementType)
.fi
.SS "return pointer"

.SS "\fBpointer\fP size = 0"

.SH "Author"
.PP 
Generated automatically by Doxygen for StackRigid from the source code\&.
